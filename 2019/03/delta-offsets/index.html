<!doctype html><html lang=en-us><head><title>Delta Offsets | VeXation</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Using the &ldquo;delta offset&rdquo; approach to make the PE infector virus position independent."><meta name=generator content="Hugo 0.99.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/about>About</a>
<a class=button href=https://log.vexation.ca/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>Delta Offsets</h1><div class=tip><time datetime="2019-03-11 00:00:00 +0000 UTC">Mar 11, 2019</time></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#recap>Recap</a></li><li><a href=#code-and-data>Code and Data</a></li><li><a href=#code-is-data-is-code>Code is Data is Code</a></li><li><a href=#the-trap-of-position-dependence>The trap of position dependence</a></li><li><a href=#enter-the-Œ¥-offset>Enter, the Œî offset</a><ul><li><a href=#calculating-the-delta-offset>Calculating the delta offset</a></li><li><a href=#using-the-delta-offset>Using the delta offset</a></li></ul></li><li><a href=#patching-the-target-entrypoint>Patching the target entrypoint</a></li><li><a href=#complete-assembly-code>Complete Assembly code</a><ul><li><a href=#observing-the-delta-offset-in-action>Observing the delta offset in action</a></li></ul></li><li><a href=#closing-notes>Closing notes</a></li></ul></nav></div></details></aside><div class=content><p>Welcome back! If this is your first visit to VeXation you may want to start by reading about <a href=/2019/01/lets-write-a-virus/>the project</a>, the <a href=/2019/01/getting-set-up/>development environment</a>, or the work in progress <a href=/2019/01/pe-file-infector-basics/>PE infector virus</a> I&rsquo;m extending in this post.</p><h1 id=recap>Recap <a href=#recap class=anchor>üîó</a></h1><p>At the end of the <a href=/2019/01/pe-file-infector-basics/>last post</a> I completed <a href=https://github.com/cpu/vexation/tree/cpu-pijector-wip/minijector target=_blank rel=noopener><code>minijector</code></a>, a PE executable file infector virus that can add its code to <code>.exe</code> files found in the same directory by adding a new section to the to-be-infected target. There are a handful of shortcomings that prevent <code>minijector</code> from being a real functional virus. To recap, the virus code quickly falls apart for generations after 0:</p><ol><li>The virus code relies on a data section that isn&rsquo;t copied into the infected program. Variable references will all be broken.</li><li>The way the virus code uses Win32 API functions will not work - a layer of indirection was broken and the first API function call will crash.</li><li>The virus code is inert. The entrypoints of infected programs aren&rsquo;t being updated.</li></ol><p>Today I&rsquo;ll describe the approach I took to fix the first of these three problems: making the virus self-contained and position independent.</p><h1 id=code-and-data>Code and Data <a href=#code-and-data class=anchor>üîó</a></h1><p>A big problem with Minijector is that its <code>CODE</code> section refers to variables in a separate <code>DATA</code> section. When Minijector&rsquo;s code is copied into generation 1+ all of the variables are left behind and the references will be invalid!</p><p>I found it helpful to get an intuition for this using <code>tdump</code> on the <code>minijector.exe</code> executable. <em>(If this idea already makes plenty of sense to you feel free to <a href=#code-is-data-is-code>skip ahead</a>)</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Turbo Dump  Version 4.2.16.1 Copyright (c) 1988, 1996 Borland International
</span></span><span style=display:flex><span>                  Display of File MINIJECTOR.EXE
</span></span><span style=display:flex><span>&lt;snipped&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  CODE      00001000  00001000  00000400  00000600  60000020 [CER]
</span></span><span style=display:flex><span>02  DATA      00001000  00002000  00000400  00000A00  C0000040 [IRW]
</span></span><span style=display:flex><span>03  .idata    00001000  00003000  00000200  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .reloc    00001000  00004000  00000200  00001000  50000040 [ISR]
</span></span></code></pre></div><p>The <code>tdump</code> output shows there&rsquo;s both a <code>CODE</code> and a <code>DATA</code> section present in the object table and that each has a non-zero <code>PhysSize</code>.</p><p>(<em>Side note: The names of these sections is a give-away that I used Borland Turbo Assembler. Other assemblers will choose different names. For example, <code>calc.exe</code> was built by Microsoft with a different set of tools and as a result it has a <code>.text</code> section instead of a <code>CODE</code> section</em>).</p><p>Turning to <a href=https://github.com/cpu/vexation/blob/master/minijector/calc.exe.tdump.txt target=_blank rel=noopener>a <code>tdump</code></a> of a <code>calc.exe</code> instance infected by <code>minijector.exe</code> I can see there&rsquo;s just one new section above and beyond <a href=https://github.com/cpu/vexation/blob/master/minijector/calc.clean.exe.tdump.txt target=_blank rel=noopener>the original</a> <code>calc.exe</code> sections, <code>.ireloc</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Turbo Dump  Version 4.2.16.1 Copyright (c) 1988, 1996 Borland International
</span></span><span style=display:flex><span>                     Display of File CALC.EXE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;snipped&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000096B0  00001000  00009800  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .bss      0000094C  0000B000  00000000  00000000  C0000080 [URW]
</span></span><span style=display:flex><span>03  .data     00001700  0000C000  00001800  00009C00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    00000B64  0000E000  00000C00  0000B400  40000040 [IR]
</span></span><span style=display:flex><span>05  .rsrc     000015CC  0000F000  00001600  0000C000  40000040 [IR]
</span></span><span style=display:flex><span>06  .reloc    00001040  00011000  00001200  0000D600  42000040 [IDR]
</span></span><span style=display:flex><span>07  .ireloc   00001000  00013000  00000400  0000E800  E0000020 [CERW]
</span></span></code></pre></div><p>Since the virus code was using <strong>two</strong> sections (<code>CODE</code> and <code>DATA</code>) in the original <code>minijector.exe</code> and there&rsquo;s only <strong>one</strong> new section in <code>calc.exe</code> (<code>.ireloc</code>) it&rsquo;s easy to understand there is a mismatch that needs to be addressed.</p><h1 id=code-is-data-is-code>Code is Data is Code <a href=#code-is-data-is-code class=anchor>üîó</a></h1><p>It&rsquo;s tempting to think about fixing this problem by duplicating the process generation 0 uses to copy its <code>CODE</code> section to the injected <code>.ireloc</code> section and using it to also copy a <code>DATA</code> section. Overall this approach seemed like the wrong solution to me. It will be more complex managing injecting multiple sections and as mentioned in the <a href=/2019/01/pe-file-infector-basics/>previous post</a> adding a new section is already pretty clumsy from an AV evasion perspective. Continuing to pile new sections into a target isn&rsquo;t very appealing.</p><p>The route I decided to follow was to remove the <code>DATA</code> section entirely and have the virus maintain and update variables inside of its existing <code>CODE</code> section. I started by copying the <code>minijector</code> folder from the <a href=https://github.com/cpu/vexation target=_blank rel=noopener>VeXation repo</a> to create <a href=https://github.com/cpu/vexation/tree/master/pijector target=_blank rel=noopener>a <code>pijector</code> folder</a> (<em>position independent (in)jector, get it?</em>). Updating all of the old <code>"minijector"</code> references in the <code>Makefile</code>, <code>.inc</code>, <code>.def</code>, and <code>.asm</code> files was enough to get started on a position independent version of <code>minijector</code>.</p><p>From an Assembly programming standpoint there&rsquo;s only one change that needs to be made. The <a href=https://github.com/cpu/vexation/blob/b3a2897311aa8c358d0ec1a24b9b8f045cfb21f1/minijector/minijector.asm#L23-L48 target=_blank rel=noopener>old <code>.data</code> section</a> from <code>minijector.asm</code> is moved <a href=https://github.com/cpu/vexation/blob/4bf1084bffdfaf1b3d0c5cf3a2c137e107145137/pijector/pijector.asm#L465-L491 target=_blank rel=noopener>inside of the <code>.code</code> section</a>. Done!</p><p>For unsatisfying and vague reasons I found I couldn&rsquo;t delete the <code>.data</code> section outright or <code>tasm32</code> and <code>tlink32</code> would wig out and create a generation 0 binary that would crash immediately. Rather than spend time figuring out why I decided to hack around it by <a href=https://github.com/cpu/vexation/blob/4bf1084bffdfaf1b3d0c5cf3a2c137e107145137/pijector/pijector.asm#L13-L22 target=_blank rel=noopener>adding a tiny <code>.data</code> section</a> that isn&rsquo;t used for anything:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#66d9ef>.data</span><span style=color:#66d9ef>
</span></span></span><span style=display:flex><span><span style=color:#66d9ef>  DB</span> ?
</span></span></code></pre></td></tr></table></div></div><p>With the old <code>.data</code> section moved to <code>.code</code> and replaced with an empty <code>.data</code> section the assembled <code>pijector.exe</code> should have a non-empty <code>CODE</code> section and an empty <code>DATA</code> section on disk. A quick <code>tdump</code> shows that this worked out as expected:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Turbo Dump  Version 4.2.16.1 Copyright (c) 1988, 1996 Borland International
</span></span><span style=display:flex><span>                   Display of File PIJECTOR.EXE
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;snipped&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  CODE      00001000  00001000  00000800  00000600  60000020 [CER]
</span></span><span style=display:flex><span>02  DATA      00001000  00002000  00000000  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>03  .idata    00001000  00003000  00000200  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .reloc    00001000  00004000  00000200  00001000  50000040 [ISR]
</span></span></code></pre></div><p>Unlike before the <code>PhysSize</code> of the <code>DATA</code> section is now <code>00000000</code>.</p><h1 id=the-trap-of-position-dependence>The trap of position dependence <a href=#the-trap-of-position-dependence class=anchor>üîó</a></h1><p>Consolidating to one section is a step in the right direction but it&rsquo;s only a half-solution for making sure the virus code from generation 0 still works when run from a new location in generation 1+.</p><p>I found it was easier to understand the remaining problem by poking at it with some tools. Running <code>td32</code> on an old <code>minijector.exe</code> build without debug symbols makes it easy to see how variable references in the code end up looking in the assembled executable.</p><p>There&rsquo;s an example of variables being used <a href=https://github.com/cpu/vexation/blob/4bf1084bffdfaf1b3d0c5cf3a2c137e107145137/minijector/minijector.asm#L54-L63 target=_blank rel=noopener>right at the beginning of the <code>minijector.asm</code> code</a> that shows the problem in concrete terms:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>findfirst:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> eax, offset infectFilter
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> ebx, offset findData
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span> FindFirstFileA, eax, ebx
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>snipped</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> [findHandle], eax
</span></span></code></pre></td></tr></table></div></div><p>Here <code>eax</code> and <code>ebx</code> are being used as arguments to <code>FindFirstFileA</code>. Both arguments are a pointer to a memory address. In this case pointers to the memory addresses of the variables <code>infectFilter</code> and <code>findData</code> respectively. After calling <code>FindFirstFileA</code> the result in the <code>eax</code> register is saved in the <code>findHandle</code> variable.</p><p>In <code>td32</code> the debugger&rsquo;s view of this code&rsquo;s disassembly looks a little bit different. Most importantly the <code>offset infectFilter</code>, <code>offset findData</code> and <code>[findHandle]</code> instances have been replaced with memory addresses:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>mov</span> eax, <span style=color:#ae81ff>004014</span>E6
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> ebx, <span style=color:#ae81ff>004013</span>A8
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span> ebx
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span> eax
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span> PIJECTOR.0040163A
</span></span><span style=display:flex><span><span style=color:#75715e>; &lt;snipped&gt;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> [PIJECTOR.004013A4], eax
</span></span></code></pre></td></tr></table></div></div><p>The addresses of the variables are offsets from where the OS loaded <code>minijector.exe</code> in memory, the <strong>base address</strong>.</p><p>In this case the base address is <code>0x00400000</code> and the <code>infectFilter</code> variable is at an offset of <code>0x14E6</code>, the <code>findData</code> variable is at an offset of <code>0x13A8</code> and the <code>findHandle</code> variable is at an offset of <code>0x13A4</code>.</p><p>(<em>Side Note:</em> You can also see the <a href=https://en.wikipedia.org/wiki/X86_calling_conventions#stdcall target=_blank rel=noopener>stdcall calling convention</a> in action here. In the debugger view you can see the assembler helpfully replaced the arguments to each <code>call</code> instruction with <code>push</code> operations in the correct reversed order for the convention in use.)</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.1.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.1_hu48defcae675185215a9db8defa869699_26365_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.1_hu48defcae675185215a9db8defa869699_26365_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.1_hu48defcae675185215a9db8defa869699_26365_800x0_resize_q75_h2_box_3.webp><img alt="TD32 screenshot" title="TD32 screenshot" src=td32.1.png loading=lazy class=img-fluid></picture></a><figcaption>Debugging pijector.exe to see variable reference offsets.</figcaption></figure></p></p><p>The <code>infectFilter</code>, <code>findData</code> and <code>findHandle</code> offsets work correctly in generation 0 because the assembler and linker calculated them knowing where the <code>CODE</code> section will be relative to the loaded base address.</p><p>The same offsets will be a complete disaster in later generations because the virus code from the generation 0 <code>CODE</code> section won&rsquo;t be located in the expected place anymore (the first section in the executable). Instead it will be running from the <code>.ireloc</code> section that gets appended at the <strong>end</strong> of infected executables.</p><p>For example if the <code>findfirst</code> code from above were injected into <code>calc.exe</code> the offset for the <code>infectFilter</code> variable (<code>0x14E6</code>) would be pointing somewhere inside <code>calc.exe</code>&rsquo;s original code in the <code>.text</code> section and <strong>not</strong> at the location of the infection filter variable in the virus code. That&rsquo;s obviously not going to work so what can be done?</p><h1 id=enter-the-Œ¥-offset>Enter, the Œî offset <a href=#enter-the-%ce%b4-offset class=anchor>üîó</a></h1><p>The solution to this problem is a well known trick in the VX and AV community called <em>&ldquo;the delta offset&rdquo;</em>.</p><p>The core idea is to figure out at runtime the difference in location between where the virus code was originally being run in generation 0, and the location where the virus code is currently running in an infected executable. The difference in location is the <strong>delta offset</strong> and by adding it to all of the original variable offsets in the virus code they will remain correct even when the code is moved to a new location.</p><h2 id=calculating-the-delta-offset>Calculating the delta offset <a href=#calculating-the-delta-offset class=anchor>üîó</a></h2><p>There are a handful of different ways to compute a delta offset but the standard textbook approach is to exploit the relative nature of <code>call</code> and its effect on the stack. Here&rsquo;s an example:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>  <span style=color:#a6e22e>call</span> @@delta
</span></span><span style=display:flex><span>@@delta:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>pop</span> ebp
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sub</span> ebp, offset @@delta
</span></span><span style=display:flex><span>  <span style=color:#75715e>; ebp is now the ~*[ holy delta offset ]*~</span>
</span></span></code></pre></td></tr></table></div></div><p>How does this magic incantation work? Well, there&rsquo;s a lot going on in just ~4 lines of assembly so let&rsquo;s break it down.</p><p>The first <code>call</code> on L1 is to a locally scoped label (<code>@@delta</code>, on L2) for the address immediately after the <code>call</code> instruction (L3). When the <code>call</code> instruction is executed the return address (the address of the instruction after <code>call</code>) will be pushed onto the top of the stack as a side-effect of how <code>call</code> works.</p><p>In this case however we don&rsquo;t care about returning from a procedure call, we just want to know where this code is executing from in memory. A <code>pop</code> of the top of the stack into <code>ebp</code> (L3) puts the return address from the <code>call</code> instruction that was just executed into <code>ebp</code> (recall that the return address will be the address of the instruction after the <code>call</code>, the <code>pop ebp</code> instruction on L3).</p><p>Now comes the last trick on L on L44: subtracting the original label offset (<code>offset @@delta</code>) from the address of the <code>pop ebp</code> instruction (currently in <code>ebp</code>). This gives the difference between where the <code>pop ebp</code> instruction would have been in generation 0 and wherever the <code>pop ebp</code> instruction happens to be now: the delta offset!</p><h2 id=using-the-delta-offset>Using the delta offset <a href=#using-the-delta-offset class=anchor>üîó</a></h2><p>I used <code>ebp</code> to hold the delta offset in the above snippet and in my virus code so to rewrite the original <code>findfirst</code> snippet to be position independent means going from something like:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>findfirst:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> eax, offset infectFilter
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> ebx, offset findData
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span> FindFirstFileA, eax, ebx
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>snipped</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> [findHandle], eax
</span></span></code></pre></td></tr></table></div></div><p>to an updated version that takes into account the delta offset in <code>ebp</code> for each variable reference:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>findfirst:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> eax, offset infectFilter
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>add</span> eax, ebp
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> ebx, offset findData
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>add</span> ebx, ebp
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span> FindFirstFileA, eax, ebx
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>&lt;</span><span style=color:#a6e22e>snipped</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> [ebp <span style=color:#f92672>+</span> findHandle], eax
</span></span></code></pre></td></tr></table></div></div><p>In <code>pijector.asm</code> I rewrote all of the original <code>minijector.asm</code> variable references following the same process shown above. Now the virus code and variables are self-contained in the <code>DATA</code> section and the variable references are position independent thanks to the delta offset!</p><h1 id=patching-the-target-entrypoint>Patching the target entrypoint <a href=#patching-the-target-entrypoint class=anchor>üîó</a></h1><p>In order to see the delta offset calculation in action it&rsquo;s handy to have executables infected by generation 0 actually <strong>run</strong> the virus code when the infected executable is started.</p><p>In future posts I&rsquo;ll cover how to do this correctly so that when the virus code is finished doing its dirty work it can return execution to the infected program&rsquo;s original entry point. For now because the virus code is still incomplete I can update the entry point to jump to the virus code and not worry about anything else. The infected programs will be broken but that&rsquo;s fine for now.</p><p>To get the virus code to be executed by the infected program I updated <code>pijector.asm</code> to <a href=https://github.com/cpu/vexation/blob/4bf1084bffdfaf1b3d0c5cf3a2c137e107145137/pijector/pijector.asm#L312-L313 target=_blank rel=noopener>set the entry point of the target executable</a> to the starting virtual address of the <code>.ireloc</code> segment (stored in <code>eax</code>):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>  <span style=color:#75715e>; While we have the virtual address pointer handy patch the entrypoint</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> (IMAGE_NT_HEADERS [ecx]).OptionalHeader.AddressOfEntryPoint, eax
</span></span></code></pre></div><h1 id=complete-assembly-code>Complete Assembly code <a href=#complete-assembly-code class=anchor>üîó</a></h1><p>The complete <code>pijector</code> assembly code is available in the <a href=https://github.com/cpu/vexation/ target=_blank rel=noopener>VeXation github repo</a> in the <a href=https://github.com/cpu/vexation/tree/master/pijector target=_blank rel=noopener>pijector folder</a>.</p><p>Like with Minijector the code can be built by running <code>make</code> in the <code>pijector</code> directory (Or use <code>make</code> with a <code>-DDEBUG</code> argument to build with debug symbols). Executing <code>make run</code> will copy a clean <code>calc.exe</code> into the project directory and start <code>pijector.exe</code> in Borland Turbo Debugger. That will let you step through infecting <code>calc.exe</code>. <em>Remember that after being infected <code>calc.exe</code> will be broken because the virus isn&rsquo;t complete yet but the entry-point was changed.</em></p><h2 id=observing-the-delta-offset-in-action>Observing the delta offset in action <a href=#observing-the-delta-offset-in-action class=anchor>üîó</a></h2><p>The delta offset is confusing to reason about statically. I found it much easier to understand when I could step through generation 0&rsquo;s calculation and compare it to generation 1&rsquo;s calculation. Here&rsquo;s a brief run through of how I did that.</p><p>First I ran <code>make clean</code> and <code>make -DDEBUG</code> in the <code>pijector</code> directory to get a debug build. Then I ran <code>make run</code> to step through generation 0 in the debugger.</p><p>For this task I found it useful to use the &ldquo;CPU&rdquo; view instead of the source view so I clicked &ldquo;View&rdquo; then &ldquo;CPU&rdquo; and then maximized the CPU view window.</p><h3 id=generation-0>Generation 0 <a href=#generation-0 class=anchor>üîó</a></h3><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.2.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.2_hu752ff7f34f206ae0dacfd021a0f61685_27034_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.2_hu752ff7f34f206ae0dacfd021a0f61685_27034_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.2_hu752ff7f34f206ae0dacfd021a0f61685_27034_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view screenshot at load" title="TD32 Debugger CPU view screenshot at load" src=td32.2.png loading=lazy class=img-fluid></picture></a><figcaption>Debugging pijector.exe in CPU view.</figcaption></figure></p></p><p>After the debugger loads execution is paused on the first part of the delta offset calculation at address <code>0x00401000</code>. In the bottom right I can see the top of the stack is at address <code>0x0063FE3C</code> and the value is <code>0xBFF88E93</code>.</p><p>After stepping forward one instruction by pressing <code>F8</code> the debugger will look as follows in the CPU view window:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.3.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.3_huffa4562c423bfa85c8b64396c7c49130_27298_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.3_huffa4562c423bfa85c8b64396c7c49130_27298_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.3_huffa4562c423bfa85c8b64396c7c49130_27298_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view one step forward" title="TD32 Debugger CPU view one step forward" src=td32.3.png loading=lazy class=img-fluid></picture></a><figcaption>One step into the pijector.exe delta offset calculation.</figcaption></figure></p></p><p>Now the top of the stack is <code>0x0063FE38</code> and has the new value <code>0x00401005</code>. I can cross-reference that with the primary disassembly view to see that <code>0x00401005</code> is the address of the <code>pop ebp</code> instruction, just as expected.</p><p>After stepping forward with <code>F8</code> once more the debugger will look as follows:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.4.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.4_hue64295eba363dd207e820139104bd729_28225_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.4_hue64295eba363dd207e820139104bd729_28225_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.4_hue64295eba363dd207e820139104bd729_28225_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view two steps forward" title="TD32 Debugger CPU view two steps forward" src=td32.4.png loading=lazy class=img-fluid></picture></a><figcaption>Two steps into the pijector delta offset calculation.</figcaption></figure></p></p><p>Now the virus code has popped the top of the stack into the <code>ebp</code> register and it holds the value <code>0x00401005</code>. This value is the address of the <code>pop ebp</code> instruction, so far so good.</p><p>Finally by pressing <code>F8</code> one last time the debugger will show the end of the delta offset calculation:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.5.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.5_hu348071344191e1b54e511a29ce6777e9_27266_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.5_hu348071344191e1b54e511a29ce6777e9_27266_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.5_hu348071344191e1b54e511a29ce6777e9_27266_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view three steps forward" title="TD32 Debugger CPU view three steps forward" src=td32.5.png loading=lazy class=img-fluid></picture></a><figcaption>The end of the pijector delta offset calculation.</figcaption></figure></p></p><p>Now <code>offset @@delta</code> has been subtracted from <code>ebp</code> and it&rsquo;s left holding the value <code>0x00000000</code>.</p><p>Wait a second. All zero? Is that right?</p><p>Yes! Remember that this is generation 0 so the code is executing from the place the assembler/linker put it. All of the original offsets are correct as-is. In this case the delta offset that needs to be applied is 0 and so the calculation is correct.</p><p>After hitting <code>F9</code> to continue execution the <code>pejector.exe</code> process will finish its work and terminate and I&rsquo;m left with an infected <code>calc.exe</code> to repeat the process with.</p><h3 id=generation-1>Generation 1 <a href=#generation-1 class=anchor>üîó</a></h3><p>Now that I have an infected generation 1 <code>calc.exe</code> I can see how its delta offset calculation produces a different result than generation 0.</p><p>Running <code>td32 calc.exe</code> loads the generation 1 program and pauses execution at a debugger screen like this (after dismissing the warning about missing symbols):</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.6.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.6_hu7c60bde19361911a339861b433cea5ec_25184_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.6_hu7c60bde19361911a339861b433cea5ec_25184_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.6_hu7c60bde19361911a339861b433cea5ec_25184_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view of infected exe" title="TD32 Debugger CPU view of infected exe" src=td32.6.png loading=lazy class=img-fluid></picture></a><figcaption>An infected calc.exe in CPU view.</figcaption></figure></p></p><p>Right away I can use the debugger&rsquo;s output to see the entry point patching worked because the debugger is paused at <code>0x00413000</code> which is the base address of where <code>calc.exe</code> is loaded (<code>0x00400000</code>) plus the RVA of the <code>.ireloc</code> section <a href=https://github.com/cpu/vexation/blob/master/pijector/calc.infected.exe.tdump.txt target=_blank rel=noopener>shown in <code>tdump calc.exe</code></a> (<code>0x00013000</code>). The disassembly is also clearly the delta offset calculation from the virus code and not some part of the original <code>calc.exe</code> code.</p><p>Now I can follow the same process as before, single stepping with <code>F8</code> and watching the delta offset calculation happen piece by piece. After one step forward the debugger view will look as follows:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.7.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.7_huf9cd422d6e9cf0ffe3b8c1c10ea1a62d_25905_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.7_huf9cd422d6e9cf0ffe3b8c1c10ea1a62d_25905_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.7_huf9cd422d6e9cf0ffe3b8c1c10ea1a62d_25905_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view one step forward" title="TD32 Debugger CPU view one step forward" src=td32.7.png loading=lazy class=img-fluid></picture></a><figcaption>One step into the calc.exe delta offset calculation.</figcaption></figure></p></p><p>Like before the <code>call</code> instruction changed the top of the stack. Now the top of the stack is <code>0x0064FE38</code> and has the value <code>0x00413005</code>. That&rsquo;s the address of the <code>pop ebp</code> instruction that follows the <code>call</code> in the disassembly view so the calculation appears the same as generation 0 so far.</p><p>Stepping forward once more with <code>F8</code> gives the following view:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.8.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.8_hufffa0e9b593334a145ce856f839667cc_26252_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.8_hufffa0e9b593334a145ce856f839667cc_26252_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.8_hufffa0e9b593334a145ce856f839667cc_26252_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view two steps forward" title="TD32 Debugger CPU view two steps forward" src=td32.8.png loading=lazy class=img-fluid></picture></a><figcaption>Two steps into the calc.exe delta offset calculation.</figcaption></figure></p></p><p>Now <code>ebp</code> holds <code>0x00413005</code>, the address of the <code>pop ebp</code> instruction after the <code>call</code>. This still matches what happened in generation 0, no surprises.</p><p>One more step forward with <code>F8</code> shows the critical difference in generation 1&rsquo;s delta offset calculation:</p><p><p class=markdown-image><figure><a href=/2019/03/delta-offsets/td32.9.png><picture><source media="(max-width: 420px)" srcset=/2019/03/delta-offsets/td32.9_hu3e55f5b93d9269c4d79c934350409fcd_26209_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/03/delta-offsets/td32.9_hu3e55f5b93d9269c4d79c934350409fcd_26209_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/03/delta-offsets/td32.9_hu3e55f5b93d9269c4d79c934350409fcd_26209_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger CPU view three steps forward" title="TD32 Debugger CPU view three steps forward" src=td32.9.png loading=lazy class=img-fluid></picture></a><figcaption>The end of the calc.exe delta offset calculation.</figcaption></figure></p></p><p>After subtracting <code>offset @@delta</code> the <code>ebp</code> register is left with the value <code>0x00012000</code> and not <code>0x00000000</code>. This value (<code>0x00012000</code>) is the generation 1 delta offset!</p><p>The easiest way to verify this is the correct delta offset for the <code>calc.exe</code> generation 1 infection is to compare the <code>tdump</code> of the generation 0 <code>pijector.exe</code> and the infected <code>calc.exe</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>---------------------------[ Generation 0 ]--------------------------------
</span></span><span style=display:flex><span>Turbo Dump  Version 4.2.16.1 Copyright (c) 1988, 1996 Borland International
</span></span><span style=display:flex><span>                   Display of File PIJECTOR.EXE
</span></span><span style=display:flex><span>&lt;snipped&gt;
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  CODE      00001000  00001000  00000800  00000600  60000020 [CER]
</span></span><span style=display:flex><span>02  DATA      00001000  00002000  00000000  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>03  .idata    00001000  00003000  00000200  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .reloc    00001000  00004000  00000200  00001000  50000040 [ISR]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>---------------------------[ Generation 1 ]--------------------------------
</span></span><span style=display:flex><span>Turbo Dump  Version 4.2.16.1 Copyright (c) 1988, 1996 Borland International
</span></span><span style=display:flex><span>                    Display of File CALC.INFECTED.EXE
</span></span><span style=display:flex><span>&lt;snipped&gt;
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000096B0  00001000  00009800  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .bss      0000094C  0000B000  00000000  00000000  C0000080 [URW]
</span></span><span style=display:flex><span>03  .data     00001700  0000C000  00001800  00009C00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    00000B64  0000E000  00000C00  0000B400  40000040 [IR]
</span></span><span style=display:flex><span>05  .rsrc     000015CC  0000F000  00001600  0000C000  40000040 [IR]
</span></span><span style=display:flex><span>06  .reloc    00001040  00011000  00001200  0000D600  42000040 [IDR]
</span></span><span style=display:flex><span>07  .ireloc   00001000  00013000  00000800  0000E800  E0000020 [CERW]
</span></span></code></pre></div><p>In the <code>pijector.exe</code> <code>tdump</code> output the <code>CODE</code> section is located at RVA <code>0x00001000</code>. In the infected <code>calc.exe</code> the <code>.ireloc</code> section is located at RVA <code>0x00013000</code>.</p><p>Taking <code>0x00013000 - 0x00001000</code> gives <code>0x00012000</code>, the same delta offset that <code>calc.exe</code> calculated at runtime. Right-on! Now throughout this instance of the virus code variable references can be corrected for their current location by simply adding <code>0x00012000</code> to the original variable offset.</p><h1 id=closing-notes>Closing notes <a href=#closing-notes class=anchor>üîó</a></h1><p>There is still <strong>one</strong> big problem left to address before <code>pijector</code> could be a real functional virus: the way the virus code uses Win32 API functions won&rsquo;t work in generations 1+.</p><p>If a program infected by <code>pijector</code> is run it will immediately crash at the first invocation of <code>FindFirstFileA</code>. Fixing this problem is going to take even more runtime contortions and I&rsquo;ll save that for the next post :-) <em>It&rsquo;s a lot of work to make a functional virus!</em></p><p>Beyond that big problem there&rsquo;s also a smaller problem: the generation 0 <code>pijector.exe</code> binary will only work if it&rsquo;s run under <code>td32</code> or another debugger. The reason is fairly simple to understand: moving the old <code>.data</code> section into the <code>.code</code> section means the virus is <strong>writing</strong> to its own code section and that&rsquo;s not what Borland Turbo Assembler expected: it created the section read-only.</p><p>When <code>tasm32/tlink32</code> builds the generation 0 <code>pijector.exe</code> binary the <code>CODE</code> section it creates is marked <code>CER</code> (contains code, executable, readable). Notably it doesn&rsquo;t have the <code>W</code> flag for &ldquo;writable&rdquo;. This is only a problem for generation 0 because every subsequent generation will have virus code located in a section that the previous generation of the virus created, not Borland, and the virus code always makes the sections it creates writable.</p><p>The generation 0 binary works correctly when run in <code>td32</code> because it (and other debuggers) make the code section of the debugged program writable in order to be able to add breakpoints. One way to remove the dependence on using a debugger to run generation 0 is to write a small utility program that can edit generation 0&rsquo;s <code>CODE</code> section metadata after the executable is built to have the writable flag. I&rsquo;m already strapped for time so for now I live with always running generation 0 in a debugger :-)</p><p>Thanks for sticking with me while I go on this VXing journey. As always, I would love to hear feedback about this project. Feel free to drop me a line on twitter (<a href=https://twitter.com/cpu target=_blank rel=noopener>@cpu</a>) or by email (<a href=mailto://daniel@binaryparadox.net>daniel@binaryparadox.net</a>).</p></div><nav class=bottom_nav><ul><li style=flex:1><a rel=prev href=https://log.vexation.ca/2019/01/pe-file-infector-basics/>‚Üê PE File Infector Basics</a></li><li style="flex:1 0 80px;text-align:center"><button onclick="document.body.scrollTop=0,document.documentElement.scrollTop=0,event.preventDefault()">
‚Üë Back to top</button></li><li style=flex:1><a href=https://log.vexation.ca/2019/04/using-kernel32.dll-exports-like-a-virus/>Using kernel32.dll exports like a virus ‚Üí</a></li></ul></nav></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/cpu/vexation rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/cpu rel=me target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><div class=copyright>¬© Copyright
2022
<span class=split><a style=text-decoration:none;color:currentColor;cursor:not-allowed href=https://monkeypunch.biz>‚ò†</a></span>
Daniel McCarney</div></footer></body></html>