<!doctype html><html lang=en-us><head><title>Don't be suspicious | VeXation</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Redirecting control-flow back to an infected program&rsquo;s original entry-point."><meta name=generator content="Hugo 0.99.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/custom.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon></head><body><nav class=navigation><a href=/><span class=arrow>‚Üê</span>Home</a>
<a href=/posts>Archive</a>
<a href=/about>About</a>
<a class=button href=https://log.vexation.ca/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>Don't be suspicious</h1><div class=tip><time datetime="2019-08-29 00:00:00 +0000 UTC">Aug 29, 2019</time></div><aside class=toc><details><summary>Table of Contents</summary><div><nav id=TableOfContents><ul><li><a href=#continued-recap>Continued Recap</a></li><li><a href=#the-problem-at-hand>The problem at hand</a><ul><li><a href=#confirmation>Confirmation</a></li></ul></li><li><a href=#a-direct-solution>A direct solution</a><ul><li><a href=#saving-the-original-entry-rva>Saving the original entry RVA</a></li><li><a href=#jumping-to-the-original-entry-rva>Jumping to the original entry RVA</a></li></ul></li><li><a href=#complete-assembly>Complete Assembly</a></li><li><a href=#a-more-subtle-virus>A more subtle virus</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></aside><div class=content><p>Welcome back! If this is your first visit to VeXation you may want to start at <a href=../welcome>the beginning</a>.</p><h1 id=continued-recap>Continued Recap <a href=#continued-recap class=anchor>üîó</a></h1><p>At the end of the <a href=../kernel32-dll-exports>last post</a> I had completed <a href=https://github.com/cpu/vexation/tree/master/apisafejector target=_blank rel=noopener><code>apisafejector</code></a>, a self-replicating position independent PE infector virus that avoids hard-coded Win32 API addresses. While <code>apisafejector</code> is a real improvement over <a href=https://github.com/cpu/vexation/tree/master/minijector target=_blank rel=noopener>earlier</a> versions and <a href=https://github.com/cpu/vexation/tree/master/pijector target=_blank rel=noopener>iterations</a> of the WIP virus it still has one large flaw: infected programs no longer work correctly!</p><p>Today I&rsquo;ll describe how I fixed this flaw and updated the virus so that the original program code is executed after propagating the infection.</p><h1 id=the-problem-at-hand>The problem at hand <a href=#the-problem-at-hand class=anchor>üîó</a></h1><p>One of the steps that <code>apisafejector</code> takes in order to get the appended virus code to be executed when an infected program is run is <a href=https://github.com/cpu/vexation/blob/480676904b8fcc39ebeed19846b28491f4e55fa2/apisafejector/apisafejector.asm#L422-L439 target=_blank rel=noopener>changing the <code>AddressOfEntryPoint</code></a> in the infected executable&rsquo;s PE header.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; eax -&gt; SecHdrVirtualAddress of .ireloc section, a RVA</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> (IMAGE_NT_HEADERS [ecx]).OptionalHeader.AddressOfEntryPoint, eax
</span></span></code></pre></div><p><a href="https://docs.microsoft.com/en-us/previous-versions/ms809762%28v=msdn.10%29#the-pe-header" target=_blank rel=noopener>&ldquo;Peering inside the PE&rdquo;</a> describes this field as:</p><blockquote><p>DWORD AddressOfEntryPoint</p><p>The address where the loader will begin execution. This is an RVA, and can usually be found in the .text section.</p></blockquote><p>In the case of <code>apisafejector</code> the virus stomps an infected program&rsquo;s true <code>AddressOfEntryPoint</code> RVA, replacing the one that pointed into the <code>.text</code> section with one that points into the <code>.ireloc</code> section where the injected virus code is. Importantly the injected virus code never invokes the program&rsquo;s real executable code that lays dormant in the <code>.text</code> section.</p><p>From a user experience perspective this means infected programs appear broken - they don&rsquo;t do anything when they are run (<em>except silently infect other executables of course</em>). This kind of side-effect is unnecessarily destructive and sure to bring attention to the virus prematurely.</p><h2 id=confirmation>Confirmation <a href=#confirmation class=anchor>üîó</a></h2><p>To get myself back into the swing of things I verified the application breaking behaviour of <code>apisafejector</code> with <code>tdump</code>, <code>td32</code> and an infected <code>calc.exe</code>.</p><p>In brief, my process was to:</p><ul><li>Build <code>apisafejector</code> without debug symbols using <code>make</code>.</li><li>Use <code>make run</code> to infect a copy of <code>calc.exe</code> by running <code>apisafejector.exe</code> in <code>td32</code> to completion.</li><li>Use <code>tdump</code> to verify <code>calc.exe</code> was infected.</li><li>Copy the infected <code>calc.exe</code> into a temp directory alongside an uninfected <code>cdplayer.exe</code></li><li>Use <code>tdump</code> to verify that the clean <code>cdplayer.exe</code> was not infected yet.</li><li>Run the infected <code>calc.exe</code>. Nothing appears to happen. No calculator appears.</li><li>Use <code>tdump</code> again to show that <code>cdplayer.exe</code> has become infected.</li><li>Run <code>cdplayer.exe</code> to show that it appears to be broken too. No CD-player UI appears.</li></ul><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/xBaSQWOEN5w style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><h1 id=a-direct-solution>A direct solution <a href=#a-direct-solution class=anchor>üîó</a></h1><p>Suspiciously breaking infected applications is a bug in the virus code that is in dire need of fixing. I went with a straight forward solution for preserving the original function of infected programs:</p><ol><li>Saving the original <code>AddressOfEntryPoint</code> value when an executable is infected into the virus code that is injected into the infected program.</li><li>Returning execution to the <code>AddressOfEntryPoint</code> saved in the virus code when the infected program is done propagating the infection.</li></ol><h2 id=saving-the-original-entry-rva>Saving the original entry RVA <a href=#saving-the-original-entry-rva class=anchor>üîó</a></h2><p>If you remember the previous <a href=../delta-offset>delta offets</a> post then you already know that the virus <em>code</em> and the virus <em>variables</em> are all in the same PE section. That makes everything self-contained and easier to inject into a new executable.</p><p>Another happy side-effect of this approach is that it&rsquo;s easy for one generation of the virus to &ldquo;pre-populate&rdquo; variables for the next generation of the virus. When the executing virus code copies itself into the <code>.ireloc</code> section of the target executable it will copy its variables with their current values in-tact.</p><p>Crucially this means that if the virus saves the original <code>AddressOfEntryPoint</code> value of a victim program before it injects itself and stomps the entry point then it will be accessible to the injected virus code later on.</p><h2 id=jumping-to-the-original-entry-rva>Jumping to the original entry RVA <a href=#jumping-to-the-original-entry-rva class=anchor>üîó</a></h2><p>With the true entry RVA of the infected program accessible the virus code can go about redirecting execution back to the original program by <code>jmp</code>ing to it.</p><p>In practice there is one extra wrinkle in the plan: the original entry RVA is just that, a <strong>R</strong>elative <strong>V</strong>irtual <strong>A</strong>ddress. It isn&rsquo;t an absolute address that the virus code can <code>jmp</code> right to. Instead it&rsquo;s an offset relative to the address the executable was loaded at by the operating system&rsquo;s <a href=https://en.wikipedia.org/wiki/Loader_%28computing%29 target=_blank rel=noopener>loader</a>.</p><p>In order to figure out the absolute address to <code>jmp</code> to the virus code needs to be able to find out what address the operating system happened to load the executable that it is running out of (often called the <em>base address</em>). I decided to use the win32 <a href=https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea target=_blank rel=noopener><code>GetModuleHandleA</code></a> function exported by <code>kernel32.dll</code> to find this. By providing a <code>NULL</code> value for the <code>lpModuleName</code> argument <code>GetModuleHandleA</code> returns the base address of the executing <code>.exe</code>.</p><p>The <a href=../kernel32-dll-exports>last VeXation post</a> laid the ground work for reliably calling exported <code>kernel32.dll</code> functions from the virus code which made it straight-forward to use <code>GetModuleHandleA</code> to find the executable&rsquo;s base address. By combining the base address with the saved original entry RVA the virus code has an absolute address to <code>jmp</code> to so the infected program can start to run normally.</p><h1 id=complete-assembly>Complete Assembly <a href=#complete-assembly class=anchor>üîó</a></h1><p>To start working on a solution to the entry point problem I used the <a href=https://github.com/cpu/vexation/tree/master/apisafejector target=_blank rel=noopener><code>apisafejector</code> project code</a> as a base, copying it into a new directory called <a href=https://github.com/cpu/vexation/tree/master/epjector target=_blank rel=noopener><code>epjector</code></a> (short for <em>&ldquo;entry-point injector&rdquo;</em> I guess?) and renaming files/includes accordingly. The majority of my changes are in <a href=https://github.com/cpu/vexation/tree/master/epjector/epjector.asm target=_blank rel=noopener><code>epjector.asm</code></a>.</p><p>To begin with I added two new variables to the <code>_data</code> label at <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/epjector.asm#L605-L661 target=_blank rel=noopener>the end of the virus code</a> to save entry point RVAs. <code>DD</code> is &ldquo;define double word&rdquo; and results in a 4 byte variable, matching the size of the <code>DWORD AddressOfEntryPoint</code> PE header field.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; Original entry-point of to-be infected .exe (or null in generation 0)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>originalEntryPoint</span><span style=color:#66d9ef>  DD</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>; Address we return control flow to after infecting (copy of original entry</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; point)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>savedEntryPoint</span><span style=color:#66d9ef>     DD</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>Next I updated the <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/epjector.asm#L322-L327 target=_blank rel=noopener><code>@@analyzepe</code> code</a> to copy the <code>AddressOfEntryPoint</code> value of the PE file being considered for infection into the <code>originalEntryPoint</code> variable before it is overwritten (respecting the delta offset in <code>ebp</code> of course).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; At this point we&#39;ve decided we have found a valid i386 PE and we can</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; analyze it for infection.</span>
</span></span><span style=display:flex><span>@@analyzepe:
</span></span><span style=display:flex><span>  <span style=color:#75715e>; Copy the original entrypoint address somewhere safe</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> ecx, (IMAGE_NT_HEADERS [eax]).OptionalHeader.AddressOfEntryPoint
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>mov</span> [ebp <span style=color:#f92672>+</span> originalEntryPoint], ecx
</span></span></code></pre></div><p>To populate <code>savedEntryPoint</code> I added some new logic at the very <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/epjector.asm#L47-L53 target=_blank rel=noopener>start of the virus code</a> immediately after calculating the delta offset:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; If this is not generation 0 then the originalEntryPoint variable will have</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; been set when the currently executing PE was infected. We need to stash that</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; somewhere we can JMP to later. We&#39;ll be writing over originalEntryPoint when</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; we find a target to infect and propagate another generation.</span>
</span></span><span style=display:flex><span>@@saveoep:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> eax, [ebp <span style=color:#f92672>+</span> originalEntryPoint]
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mov</span> [ebp <span style=color:#f92672>+</span> savedEntryPoint], eax
</span></span></code></pre></div><p>The last task is refactoring the code labelled <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/epjector.asm#L192-L209 target=_blank rel=noopener><code>findfirst</code></a> and <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/epjector.asm#L224-L240 target=_blank rel=noopener><code>findnext</code></a> to find the correct absolute address to <code>jmp</code> to using the <code>savedEntryPoint</code> RVA when there are no more <code>.exe</code>s to infect.</p><p>Previously if <code>FindFirstFileA</code> returned <code>INVALID_HANDLE_VALUE</code> (<code>-1</code>) or if <code>FindNextFileA</code> returned 0 then the virus code would <code>jmp</code> to the <code>error</code> label to exit the process. I refactored the <code>epjector</code> version of this logic to instead <code>jmp</code> to a <code>@@nofirst</code> or <code>@@nonext</code> label that invokes <code>CALL_OEP</code>. For example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span>@@nofirst:
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>CALL_OEP</span>
</span></span></code></pre></div><p>In generation 0 things are slightly different than in subsequent generations. Generation 0 has no &ldquo;original&rdquo; functionality to return execution to after infection. For all other generations the <code>savedEntryPoint</code> variable holds the RVA that the operating system loader would have used if the program wasn&rsquo;t infected.</p><p>I chose to implement finding the absolute address for the saved entry-point RVA and jumping to it as a macro called <code>CALL_OEP</code>, <a href=https://github.com/cpu/vexation/blob/ef1c6bc24bcd4951db7bc784c4c672f6cd788981/epjector/macros.inc#L82-L106 target=_blank rel=noopener>defined in <code>macros.inc</code></a>.</p><p>The macro checks the delta offset stored in <code>ebp</code> to decide if the currently executing virus code is generation 0 or not. If it is generation 0 then the macro evaluates to being the same as the old <code>apisafejector</code> behaviour, a <code>jmp</code> to the <code>error</code> label. For generations 1+ the macro evaluates to code that will <code>jmp</code> to the correct absolute address using the <code>savedEntryPoint</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-tasm data-lang=tasm><span style=display:flex><span><span style=color:#75715e>; CALL_OEP is a macro for calling the savedEntryPoint of the</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; infected EXE. If called in generation 0 it is equivalent to</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; a jmp to the error label because there is no saved entry</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; point. When called in generation 1 the GetModuleHandleA API</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; function from kernel32.dll is used to find the absolute</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; address with the savedEntryPoint RVA.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>CALL_OEP</span> MACRO
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LOCAL</span> @@notgenzero
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>LOCAL</span> @@genzero
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Use EBP to decide if this is gen &gt; 0</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cmp</span> ebp, <span style=color:#ae81ff>0h</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>je</span> @@genzero
</span></span><span style=display:flex><span>@@notgenzero:
</span></span><span style=display:flex><span>    <span style=color:#75715e>; When it isn&#39;t gen0 we need to jmp to OEP</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; First calculate the base address of the infected PE</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CALL_RUNTIME_API</span> GetModuleHandleA, <span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0h</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Then add the saved OEP</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>add</span> eax, [ebp <span style=color:#f92672>+</span> savedEntryPoint]
</span></span><span style=display:flex><span>    <span style=color:#75715e>; Bye bye! Give control to the non-viral code.</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jmp</span> eax
</span></span><span style=display:flex><span>@@genzero:
</span></span><span style=display:flex><span>    <span style=color:#75715e>; When it is gen0 we don&#39;t have an OEP to</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>; jmp to. Instead just jmp to error and ExitProcess.</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>jmp</span> error
</span></span><span style=display:flex><span><span style=color:#66d9ef>END</span>M
</span></span></code></pre></div><h1 id=a-more-subtle-virus>A more subtle virus <a href=#a-more-subtle-virus class=anchor>üîó</a></h1><p>I repeated the same process I used <a href=#confirmation>to confirm the <code>apisafejector</code> behaviour</a> to verify that <code>epjector</code> successfully hides the fact that programs are infected by preserving their original behaviour.</p><p>For <code>epjector</code> the process was to:</p><ul><li>Build <code>epjector</code> without debug symbols using <code>make</code>.</li><li>Use <code>make run</code> to infect a copy of <code>calc.exe</code> by running <code>epjector.exe</code> in <code>td32</code> to completion.</li><li>Use <code>tdump</code> to verify <code>calc.exe</code> was infected.</li><li>Copy the infected <code>calc.exe</code> into a temp directory alongside an uninfected <code>cdplayer.exe</code></li><li>Use <code>tdump</code> to verify that the clean <code>cdplayer.exe</code> was not infected yet.</li><li>Run the infected <code>calc.exe</code>. This time the calculator UI <strong>does appear</strong>!</li><li>Use <code>tdump</code> again to show that <code>cdplayer.exe</code> has become infected.</li><li>Run <code>cdplayer.exe</code>. It also works as intended and the CD player UI appears.</li></ul><div style=position:relative;padding-bottom:56.25%;height:0;overflow:hidden><iframe src=https://www.youtube.com/embed/OuiVskD6PSo style=position:absolute;top:0;left:0;width:100%;height:100%;border:0 allowfullscreen title="YouTube Video"></iframe></div><h1 id=conclusion>Conclusion <a href=#conclusion class=anchor>üîó</a></h1><p>It has taken six posts (!) but I&rsquo;ve finally arrived at an acceptable skeleton for
a PE file infector virus. It is definitely not a stealthy or sophisticated virus
but it:</p><ul><li>Successfully self-propagates within a directory.</li><li>Doesn&rsquo;t hard-code any win32 API addresses.</li><li>Doesn&rsquo;t break the infected program.</li></ul><p>There are a few directions I have in mind for future posts:</p><ul><li>Building out a payload. The virus needs to <strong>do</strong> something besides propagate itself.</li><li>Improving the infection strategy. The virus should recurse outside of the current directory.</li><li>Discussing AV. I&rsquo;d like to summarize the most glaring &ldquo;stealth&rdquo; problems with the current virus and share some results from running AV against it as-is.</li></ul><p>As always, I would love to hear feedback about this project. It would also be useful to know if one of the above directions interests you more than others. Feel free to drop me a line on twitter (<a href=https://twitter.com/cpu target=_blank rel=noopener>@cpu</a>) or by email (<a href=mailto://daniel@binaryparadox.net>daniel@binaryparadox.net</a>).</p></div><nav class=bottom_nav><ul><li style=flex:1><a rel=prev href=https://log.vexation.ca/2019/04/using-kernel32.dll-exports-like-a-virus/>‚Üê Using kernel32.dll exports like a virus</a></li><li style="flex:1 0 80px;text-align:center"><button onclick="document.body.scrollTop=0,document.documentElement.scrollTop=0,event.preventDefault()">
‚Üë Back to top</button></li><li style=flex:1><a href=https://log.vexation.ca/2021/04/switching-to-qemu/>Switching to QEMU ‚Üí</a></li></ul></nav></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/cpu/vexation rel=me target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64c4.418278.0 8-3.581722 8-8V8c0-4.418278-3.581722-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64c541083001e-24 4.418278 3.581722 8 8 8z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644c0 10.6440272 6.876 19.6751861 16.4145 22.8617681C29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482c-6.6765 1.4562499-8.085-3.2302544-8.085-3.2302544-1.0905-2.7829884-2.664-3.5239139-2.664-3.5239139C17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943c2.4075.1701719 3.675 2.4833051 3.675 2.4833051 2.142 3.6820383 5.6175 2.6188404 6.9855 2.0014024C30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671c0-2.6308879.9345-4.781379 2.4705-6.4665327C22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585c0 0 2.016-.6475568 6.6 2.4697516C31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101c4.581-3.1173084 6.5925-2.4697516 6.5925-2.4697516C49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671c0 9.2555448-5.6115 11.29309-10.9575 11.8894446.860999999999997.7439374 1.629 2.2137408 1.629 4.4621184C41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/cpu rel=me target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><div class=copyright>¬© Copyright
2022
<span class=split><a style=text-decoration:none;color:currentColor;cursor:not-allowed href=https://monkeypunch.biz>‚ò†</a></span>
Daniel McCarney</div></footer></body></html>